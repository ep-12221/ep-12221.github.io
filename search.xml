<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CODEFORCES ROUND 913 DIV.3</title>
    <url>/2023/12/06/div3/</url>
    <content><![CDATA[<h1 id="codeforces-round-913-div.3">CODEFORCES ROUND 913 DIV.3</h1>
<h2 id="第一次的cf-rated赛">第一次的cf rated赛</h2>
<p>打得依托构思</p>
<hr />
<h2 id="a.rook">A.ROOK</h2>
<p><strong><em>给出国际象棋中的车在棋盘中的棋谱位置，求出其能移动到的所有地方。</em></strong></p>
<p>水模拟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int t;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">            if (i == s[1] - &#x27;0&#x27;)</span><br><span class="line">                continue;</span><br><span class="line">            cout &lt;&lt; s[0] &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            if (i == s[0] - &#x27;a&#x27;)</span><br><span class="line">                continue;</span><br><span class="line">            cout &lt;&lt; char(i + &#x27;a&#x27;) &lt;&lt; s[1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.yetnotherrokenkeoard">B.YetnotherrokenKeoard</h2>
<p><strong><em>给出几串输入字符串，当按下“b”键时，删除键入的字符串中最后一个（最右边）小写字母。如果键入的字符串中没有小写字母，则完全忽略按键。</em></strong></p>
<p><strong><em>"B"同理。</em></strong></p>
<p>用两个栈分别维护大小写字母即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int t;</span><br><span class="line">int m[1000010];</span><br><span class="line">stack&lt;int&gt; upper;</span><br><span class="line">stack&lt;int&gt; lower;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (s[i] != &#x27;b&#x27; &amp;&amp; s[i] != &#x27;B&#x27;) &#123;</span><br><span class="line">                if (isupper(s[i]))</span><br><span class="line">                    upper.push(i);</span><br><span class="line">                else if (islower(s[i]))</span><br><span class="line">                    lower.push(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!lower.empty() &amp;&amp; s[i] == &#x27;b&#x27;)</span><br><span class="line">                    lower.pop();</span><br><span class="line">                else if (!upper.empty() &amp;&amp; s[i] == &#x27;B&#x27;)</span><br><span class="line">                    upper.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!upper.empty()) &#123;</span><br><span class="line">            m[upper.top()] = 1;</span><br><span class="line">            upper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while (!lower.empty()) &#123;</span><br><span class="line">            m[lower.top()] = 1;</span><br><span class="line">            lower.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (m[i])</span><br><span class="line">                cout &lt;&lt; s[i], m[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="c.removal-of-unattractive-pairs">C.Removal of Unattractive
Pairs</h2>
<p><strong><em>给出几串字符串，若某相邻的两个字符不同，则可以将它们从字符串中移除，求出每个字符串能达到的最小长度。</em></strong></p>
<p><strong>引理：若两个字符串除了排列顺序以外其余因素完全相同，则该两个字符串的最小长度及其对应的排列相同。</strong></p>
<p>证明：考虑归纳证明，设 $a_i $为长度为 $i $的字符串 $a
$所能达到的最小长度对应的字符串。</p>
<p>当 $n=1,2 $时显然成立；</p>
<p>假设当 $n=k
$时成立，最平凡的情况即为每个字符相等，这种情况的正确性是显然的。假若非平凡，则有
$a_{k}=b_{k} $，其中 $b $为除 $a $以外的任意一种排列。当 $n=k+1 $时，对
$a,b $增添的字母必然一致，设为 $s $。考虑到 $a $的任意性，不妨让 $a
$在其左端添上 $s $成为 $sa
$，（这是因为若需要在中间插入，则可以由另外一串字符串来证明），那么对 $b
$可以进行任意变换，使 $sa = b's $，则根据 $nk $的假设，引理得证。 $$</p>
<p>那么我们可以将每个字符串重排成一种形状：左端放满其包含最多的字符串，其余放在右端
$ LLLLLLx_1x_2$</p>
<p>那么我们可以从中间开始消消乐，关于最小长度的结论就是显然的了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int m[30];</span><br><span class="line">int t;</span><br><span class="line">deque&lt;char&gt; p;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            m[s[i] - &#x27;a&#x27;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for (int i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">            tmp = max(tmp, m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (n % 2) &#123;</span><br><span class="line">            if ((n + 1) / 2  &lt;= tmp)</span><br><span class="line">                cout &lt;&lt; 2 * (tmp - (n + 1) / 2) + 1 &lt;&lt; endl;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((n) / 2  &lt;= tmp)</span><br><span class="line">                cout &lt;&lt; 2 *(tmp - n / 2) &lt;&lt; endl;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(m, 0, sizeof(m));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="d.jumping-through-segments">D.Jumping Through Segments</h2>
<p><strong><em>按顺序给出一些区间，最小化每步都能跳到该步对应的区间中的步长的最大值，初始在零点。</em></strong></p>
<p>容易知道是二分。</p>
<p>考虑chk的写法：<strong>每次跳至的位置设置成一个区间</strong>，区间下限、上限均为相对于题给区间合法的上下限，若区间不合法(l&gt;k)即为false，否则为true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma GCC optimize(2)</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">int n,t;</span><br><span class="line">struct p&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">&#125;a[1000001];</span><br><span class="line"></span><br><span class="line">int chk(int x)&#123;</span><br><span class="line">    int l = 0,r = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        l -= x,r += x;</span><br><span class="line">        l = max(l,a[i].l);</span><br><span class="line">        r = min(r,a[i].r);</span><br><span class="line">        if(l &gt; r) return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">        int l = 0,r = 1e9 + 10;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">            if(chk(mid)) ans = mid,r = mid;</span><br><span class="line">            else l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="e.good-triples">E.Good Triples</h2>
<p><strong><em>给定若干个数 $n $，求满足 $a+b+c=n $以及 $a,b,c
$的各位和与 $n $的各位和相等的三元有序数对 $(a,b,c)
$的个数。</em></strong></p>
<p><strong>命题：满足题述条件的数对个数</strong> $ S=_{i=1}^{O(n)}()
$</p>
<p><strong>其中 $n_i $为 $n $的十进制数对应位数 $i $的数值， $O(n) $为
$n $的最高位数。</strong></p>
<p>证明：注意到所有对于 $a,b,c,n
$的各位和相等的等式均能拆成唯一一种按位排列的情形（位数不足时用0补足），即：
$ a_1 +b_1+c_1=n_1,a_2+b_2+c_2=n_2,$</p>
<p>并且上式每位数按对应位数进位后完全契合 $a+b+c=n
$，根据乘法原理，总情况数即为每位数对应分解情况数的乘积，即问题化归到求10以内的分解情况。</p>
<p>对0而言，只有唯一一种分解情况；当为 $1
$时，有三种分解情况；为2时，有六种分解情况；猜想对于 $n $，分解情况为
$_{i=1}^{1+n}i $，下面归纳证明。 $n=0 $情形已枚举；</p>
<p>假设 $n=k,n&lt;9 $时成立，则当 $ n=k+1 $时，考虑对 $n=k
$的每种情况的数对第一位加一，皆符合分解式，只缺少第一位为0的情况，即
$(0,x,y),x+y=k $，这样的数对共有0到 $k $共 $k+1
$种，这就完成了归纳证明，同时完成了命题的证明。 $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int t, n;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 1e7; i &gt;= 1; i /= 10) &#123;</span><br><span class="line">            ans *= ((n / i + 1) * (n / i + 2)) / 2;</span><br><span class="line">            n %= i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="f.shift-and-reverse">F.Shift and Reverse</h2>
<p><strong><em>给出一些数列，考虑只用头尾翻转和用头接尾两种方法能不能将该数列按照非降序排序，并求出排序步数最小值。</em></strong></p>
<p><strong>引理：将该序列看成一个尾连头的环，即 $(a_1,a_2,,a_n,a_1,)
$，若其中不重复的向右相邻的顺序与逆序的数量的最小值比1大，则无法做出排序。</strong></p>
<p>证明：若能注意到顺序逆序总和为 $n
$以及逆向构造：1.翻转让顺逆序数互换；2.尾接头最多构造出1个顺/逆序，那么结论是显然的。
$$</p>
<p>那么若能排序，则可以考虑逆向构造，在已排序环的第一第二节里截出满足与目标序列相同或只差一次翻转的序列后将需移动位置和反转次数相加，取极小即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t, n;</span><br><span class="line">int a[100001];</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        int p = 0, q = -1, ans = 0x7fffff;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (a[i] &gt; a[(i + 1) % n])&#123;</span><br><span class="line">                p++;q = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout&lt;&lt;p&lt;&lt;&quot; &quot;;</span><br><span class="line">        if (p == 0)</span><br><span class="line">            ans = 0;</span><br><span class="line">        else if (p == 1) &#123;</span><br><span class="line">            int tmp = min(q + 2, n - q);</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        p = 0,q = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (a[i] &lt; a[(i + 1) % n])&#123;</span><br><span class="line">                p++;q = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout&lt;&lt;p&lt;&lt;&quot; &quot;;</span><br><span class="line">        if (p == 0)</span><br><span class="line">            ans = 0;</span><br><span class="line">        else if (p == 1) &#123;</span><br><span class="line">            int tmp = min(q + 1, n - q + 1);</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ans == 0x7fffff)</span><br><span class="line">            ans = -1;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="g.lights">G.Lights</h2>
<p><strong><em>给出一组灯的开关状态，以及一组数 $a_1,a_2,a_n $表示开关
$i $能改变 $i,a_i
$两盏灯的状态，考虑能不能将灯全部关上，若能关上求出关上全部灯的最少步数。</em></strong></p>
<p>注意到这里共有 $n $个开关， $n
$个有向关系，可以建成一张有向图，且该图有且仅有一个环，其余的节点都为从环上衍生出去的链，那么可以考虑模拟将每个链上的灯的开关情况规整到环上，现在只需讨论环上的情况。很容易知道环上开灯的为奇数则无法关上，为偶数可以关上。</p>
<p>现在考虑怎么求最小值。其实只用求环上两个相邻开灯节点的距离最大值，然后避开这段反着扫一遍就是答案。</p>
<p>代码：改代码中</p>
]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>做题笔记2023/11/16</title>
    <url>/2023/11/17/page-1/</url>
    <content><![CDATA[<p>若不说明，下标中的数均为整数。</p>
<h1 id="线性dp">1.线性DP</h1>
<h2 id="a.poi2013-baj-bytecomputer">A.[POI2013] BAJ-Bytecomputer</h2>
<p><strong><em>给定一个长度为 <span class="math inline">\(n\)</span>
的只包含 <span class="math inline">\(-1,0,1\)</span> 的数列 <span
class="math inline">\(a\)</span>，每次操作可以使 <span
class="math inline">\(a_i\gets
a_i+a_{i-1}\)</span>，求最少操作次数使得序列单调不降。如果不可能通过该操作使得序列单调不降，请输出
<code>BRAK</code>。</em></strong></p>
<p><strong><em>数据范围：<span class="math inline">\(1\le n\le
10^6\)</span>。</em></strong></p>
<p><strong>引理</strong>：如果要求操作最少，则该数列中只有<span
class="math inline">\(1,0,-1\)</span>三种值。</p>
<p>证明：若不然，设最终序列中的第一个比<span
class="math inline">\(-1\)</span>小的数为<span
class="math inline">\(a_{i}\)</span>，注意到<span
class="math inline">\(i&gt;1\)</span>，且<span
class="math inline">\(a_{i-1}\leq
-1\)</span>，这与单调不降矛盾，比1大的情形可以类似地证明。<span
class="math inline">\(\square\)</span></p>
<p>从而该数组每个操作后的数可以唯一确定，并且若操作的数前的数列单调不降，要使包括该数在内的数列单调不降，只需要操作该数。该问题具有最优子结构且易于定态，可以考虑DP处理。设<span
class="math inline">\(dp[i][j]\)</span>为在前<span
class="math inline">\(i\)</span>个数为单调不降且第<span
class="math inline">\(i\)</span>个数为<span
class="math inline">\(j\)</span>的最小操作数，容易知道<span
class="math inline">\(dp[1][a[1]] =
0\)</span>，并将其余状态初始化为<span
class="math inline">\(+\infty\)</span>，对<span
class="math inline">\(a[i]\)</span>、<span
class="math inline">\(j\)</span>分情况讨论：</p>
<hr />
<p>若<span class="math inline">\(a[i]=-1\)</span></p>
<p>1.<span class="math inline">\(j=-1\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>只能是<span
class="math inline">\(-1\)</span>，即</p>
<p><span class="math display">\[
dp[i][-1]=dp[i-1][-1] \tag{1}
\]</span></p>
<p>2.<span
class="math inline">\(j=0\)</span>，容易知道无论前一个数是多少都无法转移。</p>
<p>3.<span class="math inline">\(j=1\)</span>,则<span
class="math inline">\(a_{i-1}\)</span>可以任取，但不能从<span
class="math inline">\(0,-1\)</span>转移得到，即</p>
<p><span class="math display">\[
dp[i][1] = dp[i-1][1]+2 \tag{2}
\]</span></p>
<hr />
<p>若<span class="math inline">\(a[i]=0\)</span></p>
<p>1.<span class="math inline">\(j=-1\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>只能是<span
class="math inline">\(-1\)</span>，即</p>
<p><span class="math display">\[
dp[i][-1]=dp[i-1][-1] + 1 \tag{3}
\]</span></p>
<p>2.<span class="math inline">\(j=0\)</span>，则前一个数可以是<span
class="math inline">\(-1,0\)</span>，即</p>
<p><span class="math display">\[
dp[i][0]=\min(dp[i-1][-1],dp[i-1][0]) \tag{4}
\]</span></p>
<p>3.<span class="math inline">\(j=1\)</span>,则<span
class="math inline">\(a_{i-1}\)</span>可以任取，但不能从<span
class="math inline">\(0,-1\)</span>转移得到，即</p>
<p><span class="math display">\[
dp[i][1] = dp[i-1][1]+1 \tag{5}
\]</span></p>
<hr />
<p>若<span class="math inline">\(a[i]=1\)</span></p>
<p>1.<span class="math inline">\(j=-1\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>不能取<span
class="math inline">\(1，0\)</span>，即</p>
<p><span class="math display">\[
dp[i][-1]=dp[i-1][-1]+2\tag{6}
\]</span></p>
<p>2.<span class="math inline">\(j=0\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>不能取<span
class="math inline">\(1，0\)</span>，即</p>
<p><span class="math display">\[
dp[i][0]=dp[i-1][-1]+1\tag{7}
\]</span></p>
<p>3.<span class="math inline">\(j=1\)</span>,则<span
class="math inline">\(a_{i-1}\)</span>可以任取，即</p>
<p><span class="math display">\[
dp[i][1]=\min(dp[i-1][-1],dp[i-1][0],dp[i-1][1]) \tag{8}
\]</span></p>
<p>综合上述八式，优化下标，查询<span
class="math inline">\(\max(dp[n][0],dp[n][1],dp[n][-1])\)</span>，若为<span
class="math inline">\(+\infty\)</span>则无解，否则输出答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n;</span><br><span class="line">int a1[N];</span><br><span class="line">int dp[N][7];</span><br><span class="line">//2=-1,3=0,4=1;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a1[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= 1000500; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 7; j++)</span><br><span class="line">            dp[i][j] = N;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a1[i]; &#125;</span><br><span class="line">    int p = a1[1];</span><br><span class="line">    dp[1][p + 3] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][2] = dp[i - 1][2] + a1[i] + 1;</span><br><span class="line">        if (a1[i] == 0)dp[i][3] = min(dp[i - 1][2], dp[i - 1][3]);</span><br><span class="line">        else if (a1[i] == 1) dp[i][3] = dp[i - 1][2] + 1;</span><br><span class="line">        if (a1[i] == 1) dp[i][4] = min(min(dp[i - 1][2], dp[i - 1][3]), dp[i - 1][4]);</span><br><span class="line">        else dp[i][4] = dp[i - 1][4] - a1[i] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[n][2] &gt;= N &amp;&amp; dp[n][3] &gt;= N &amp;&amp; dp[n][4] &gt;= N) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;BRAK&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; min(min(dp[n][3], dp[n][2]), dp[n][4]);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.scoi2009-粉刷匠">B.[SCOI2009] 粉刷匠</h2>
<p><strong><em>windy 有 <span class="math inline">\(N\)</span>
条木板需要被粉刷。 每条木板被分为 <span class="math inline">\(M\)</span>
个格子。 每个格子要被刷成红色或蓝色。</em></strong></p>
<p><strong><em>windy
每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。
每个格子最多只能被粉刷一次。</em></strong></p>
<p><strong><em>如果 windy 只能粉刷 <span
class="math inline">\(T\)</span>
次，他最多能正确粉刷多少格子？</em></strong></p>
<p><strong><em>一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。</em></strong></p>
<p><strong><em>数据范围：<span class="math inline">\(1 \le N,M \le 50,0
\le T \le 2500\)</span></em></strong></p>
<p>将每条木板看作一组物品，则题目变为分组背包。那么问题落到了如何求这一组物品的每个次数的最多正确粉刷数上。</p>
<p>考虑如何定态，首先要有涂了<span
class="math inline">\(k\)</span>次作为状态，此外还要有前<span
class="math inline">\(j\)</span>个为最小作为递推依据，用<span
class="math inline">\(i\)</span>来表示是第几条木板。在每次状态转移时，需要遍历前面所有<span
class="math inline">\(k\)</span>到<span
class="math inline">\(j\)</span>的少涂一次的状态（这是因为不可能有比<span
class="math inline">\(k\)</span>小的区间涂了k次），并加上从<span
class="math inline">\(q\)</span>到<span
class="math inline">\(j\)</span>的最多的颜色即可，即：</p>
<p><span class="math display">\[
dp1[i][j][k]=\max(dp1[i][q][k - 1] + \max(a[i][j] - a[i][q], j - q -
(a[i][j] - a[i][q])))(q\in(k,j)) \tag{1}
\]</span></p>
<p>其中<span
class="math inline">\(a[i][j]\)</span>为用0-1前缀和来存每个区间内的颜色个数。初态为<span
class="math inline">\(dp1[i][j][k]=0\)</span>。</p>
<p><strong>注意：应先循环涂的次数再循环涂了第几个，这与区间DP先循环区间长度再循环从第几个开始涂相似，都是用次数作为每一维的递推依据，再在这一维做第几个的递推。</strong></p>
<p><strong>从而<span
class="math inline">\(dp[i][m][k]\)</span>即为这一条木板粉刷次数为<span
class="math inline">\(k\)</span>时的最多粉刷格。</strong></p>
<p>最后，进行分类背包dp即可。</p>
<p><span class="math display">\[
dp[j] = \max(dp[j - k] + dp1[i][m][k])(k\in[0,m],i\in[1,n]) \tag{2}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 0x7ffff;</span><br><span class="line">int n, m, t;</span><br><span class="line">int a[100][100];</span><br><span class="line">int duan[N];</span><br><span class="line">int dp[1001];</span><br><span class="line">int sum[101][101][101];</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            char p;</span><br><span class="line">            cin &gt;&gt; p;</span><br><span class="line">            if (p == &#x27;1&#x27;)a[i][j] = 1 + a[i][j - 1];</span><br><span class="line">            else a[i][j] = a[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //要sum[i][m][j]</span><br><span class="line">    memset(sum, 0, sizeof(sum));</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int k = 1; k &lt;= m; k++) &#123;//涂了几次</span><br><span class="line">            for (int j = 1; j &lt;= m; j++) &#123;//这一行第几个</span><br><span class="line">                for (int q = k - 1; q &lt; j; q++) &#123;//遍历前几个少涂一次的情况</span><br><span class="line">                    sum[i][j][k] = max(sum[i][q][k - 1] + max(a[i][j] - a[i][q], j - q - (a[i][j] - a[i][q])), sum[i][j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = t; j &gt;= 1; j--) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] = max(dp[j - k] + sum[i][m][k], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="c.饥饿的奶牛">C.饥饿的奶牛</h2>
<p><strong><em>有 <span class="math inline">\(N\)</span>
个区间，每个区间 <span class="math inline">\(x,y\)</span> 表示提供的
<span class="math inline">\(x\sim y\)</span> 共 <span
class="math inline">\(y-x+1\)</span>
堆优质牧草。你可以选择任意区间但不能有重复的部分。</em></strong></p>
<p><strong><em>求出最多能吃到的牧草堆数。</em></strong></p>
<p><strong><em>数据范围：<span class="math inline">\(1 \leq n \leq 1.5
\times 10^5\)</span>，<span class="math inline">\(0 \leq x \leq y \leq 3
\times 10^6\)</span>。</em></strong></p>
<p>先对每个区间按照<span class="math inline">\(x\)</span>进行排序。</p>
<p>设<span class="math inline">\(dp[i]\)</span>为区间<span
class="math inline">\([1,i]\)</span>上能吃到的最多牧草。似乎如果用dp，时间复杂度<span
class="math inline">\(O(n^{2})\)</span>不可行，但我们可以进行双指针优化，对已经循环到的区间左端，遍历左端点相同的区间，更新每个左端点相同的区间的右端的值为选与不选改区间中的最大值，即：</p>
<p><span class="math display">\[
dp[a[p].r]=\max(dp[a[p].r],dp[a[p].l-1]+a[p].r-a[p].l+1) (p\in[1,n])
\tag{1}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
a[p].l=i \tag{2}
\]</span></p>
<p>对于<span class="math inline">\(i\)</span>而言，将其从1遍历到<span
class="math inline">\(max(a[n].r)\)</span>，由于不确定是不是某个区间的端点值，则直接与上一个值传递即可，若是端点值其转移已经在<span
class="math inline">\((1)\)</span>中体现，即：</p>
<p><span class="math display">\[
dp[i]=\max(dp[i-1],dp[i]) \tag{3}
\]</span></p>
<p>总而言之，i的遍历是为了保证动态转移的连续，而p的遍历是为了算出特别点的转移。</p>
<p>最后，在每次转移记录一次值更新答案即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N =0x7fffff;</span><br><span class="line">struct len&#123;</span><br><span class="line">    long long l = 0,r = 0;</span><br><span class="line">&#125;a[N];</span><br><span class="line">long long dp[N];</span><br><span class="line">bool cmp(len a,len b)&#123;</span><br><span class="line">    if(a.l == b.l) return a.r&lt;b.r;</span><br><span class="line">    return a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    long long maxy;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].l&gt;&gt;a[i].r;</span><br><span class="line">        maxy = max(maxy,a[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+n+1,cmp);</span><br><span class="line">    int p = 1;</span><br><span class="line">    long long ans =0;</span><br><span class="line">    for(int i=0;i&lt;=maxy;i++)&#123;</span><br><span class="line">        dp[i]=max(dp[i],dp[i-1]);</span><br><span class="line">        while(a[p].l == i &amp;&amp; p&lt;=n)&#123;//找左端点相同的</span><br><span class="line">            dp[a[p].r]=max(dp[a[p].r],dp[a[p].l-1]+a[p].r-a[p].l+1);//a[p].l-1是正好贴着a[p]的</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="记忆化搜索">2.记忆化搜索</h1>
<h2 id="a.noip2010-提高组-乌龟棋">A.[NOIP2010 提高组] 乌龟棋</h2>
<p><strong><em>乌龟棋的棋盘是一行 <span class="math inline">\(N\)</span>
个格子，每个格子上一个分数（非负整数）。棋盘第 <span
class="math inline">\(1\)</span> 格是唯一的起点，第 <span
class="math inline">\(N\)</span>
格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</em></strong></p>
<p><strong><em>乌龟棋中 <span class="math inline">\(M\)</span>
张爬行卡片，分成 <span class="math inline">\(4\)</span>
种不同的类型（<span class="math inline">\(M\)</span>
张卡片中不一定包含所有 <span class="math inline">\(4\)</span>
种类型的卡片），每种类型的卡片上分别标有 <span
class="math inline">\(1,2,3,4\)</span>
四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</em></strong></p>
<p><strong><em>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</em></strong></p>
<p><strong><em>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</em></strong></p>
<p><strong><em>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</em></strong></p>
<p><strong><em>数据范围： <span
class="math inline">\(1≤N≤350,1≤M≤120\)</span>，且 <span
class="math inline">\(4\)</span> 种爬行卡片，每种卡片的张数不会超过
<span class="math inline">\(40\)</span>；<span
class="math inline">\(0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M\)</span>。</em></strong></p>
<p>一道经典的记忆化搜索。用<span
class="math inline">\(dp[i][j][k][l]\)</span>表示用了<span
class="math inline">\(i\)</span>张一步卡，<span
class="math inline">\(j\)</span>张两步卡，<span
class="math inline">\(k\)</span>张三步卡，<span
class="math inline">\(l\)</span>张四步卡的最大分数，则有</p>
<p><span class="math display">\[
dp[c1][c2][c3][c4] =
\max(dp[c1-1][c2][c3][c4],dp[c1][c2-1][c3][c4],dp[c1][c2][c3-1][c4],dp[c1][c2][c3][c4-1])+a[c1
+ 2 * c2 + 3 * c3 + 4 * c4 + 1]
\]</span></p>
<p>其中<span
class="math inline">\(a[i]\)</span>为该位置的分数，初态为<span
class="math inline">\(dp[0][0][0][0]=a[1]\)</span>，其余赋值为<span
class="math inline">\(-1\)</span>。</p>
<p>按照上式dfs+剪枝即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n, m;</span><br><span class="line">int p[5];</span><br><span class="line">int a[400];</span><br><span class="line">int dp[40][40][40][40];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int dfs(int c1, int c2, int c3, int c4) &#123;</span><br><span class="line">    int t1 = -1, t2 = -1, t3 = -1, t4 = -1;</span><br><span class="line"></span><br><span class="line">    if (c1 != 0) &#123;</span><br><span class="line">        if (dp[c1 - 1][c2][c3][c4] != -1) t1 = dp[c1 - 1][c2][c3][c4] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t1 = dfs(c1 - 1, c2, c3, c4) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (c2 != 0) &#123;</span><br><span class="line">        if (dp[c1][c2 - 1][c3][c4] != -1) t2 = dp[c1][c2 - 1][c3][c4] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t2 = dfs(c1, c2 - 1, c3, c4) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (c3 != 0) &#123;</span><br><span class="line">        if (dp[c1][c2][c3 - 1][c4] != -1) t3 = dp[c1][c2][c3 - 1][c4] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t3 = dfs(c1, c2, c3 - 1, c4) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (c4 != 0) &#123;</span><br><span class="line">        if (dp[c1][c2][c3][c4 - 1] != -1) t4 = dp[c1][c2][c3][c4 - 1] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t4 = dfs(c1, c2, c3, c4 - 1) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[c1][c2][c3][c4] = max(t1, max(t2, max(t3, t4)));</span><br><span class="line"></span><br><span class="line">    return max(t1, max(t2, max(t3, t4)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        int x; cin &gt;&gt; x;</span><br><span class="line">        p[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;= 39; i++)</span><br><span class="line">        for (int j = 0; j &lt; 40; j++)</span><br><span class="line">            for (int k = 0; k &lt; 40; k++)</span><br><span class="line">                for (int l = 0; l &lt; 40; l++)</span><br><span class="line">                    dp[i][j][k][l] = -1;</span><br><span class="line">    dp[0][0][0][0] = a[1];</span><br><span class="line">    int ans = dfs(p[1], p[2], p[3], p[4]);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="区间dp">3.区间DP</h1>
<h2 id="a.cqoi2007-涂色">A.[CQOI2007] 涂色</h2>
<p><strong><em>假设你有一条长度为 <span class="math inline">\(5\)</span>
的木板，初始时没有涂过任何颜色。你希望把它的 <span
class="math inline">\(5\)</span>
个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 <span
class="math inline">\(5\)</span> 的字符串表示这个目标：$ $
。</em></strong></p>
<p><strong><em>每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成
<span class="math inline">\(\texttt{RRRRR}\)</span> ，第二次涂成 <span
class="math inline">\(\texttt{RGGGR}\)</span> ，第三次涂成 <span
class="math inline">\(\texttt{RGBGR}\)</span>
，达到目标。</em></strong></p>
<p><strong><em>用尽量少的涂色次数达到目标。</em></strong></p>
<p><strong><em>数据范围： <span class="math inline">\(1\le n\le
50\)</span> 。</em></strong></p>
<p>裸的区间dp。方程：</p>
<p><span class="math display">\[
dp[j][i + j] = min(dp[j][i + j], dp[j][j + k] + dp[j + k + 1][j + i] -
(a[j] == a[j + i]))(i\in[2,n-1],j\in[1,n-i],k\in[0,i])
\]</span></p>
<p>其中<span class="math inline">\(a[i]\)</span> 为字符串的第<span
class="math inline">\(i\)</span> 个字符，初态为<span
class="math inline">\(dp[n][n]
=1\)</span>，同时初始化含两个字符的区间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fff;</span><br><span class="line">int a[N];</span><br><span class="line">int dp[100][100];</span><br><span class="line">char x[60];</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; x; int n = 0;</span><br><span class="line">    while (x[n] &gt;= 65) &#123;</span><br><span class="line">        a[n + 1] = x[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">            dp[i][j] = 1000;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = 1;</span><br><span class="line">        if (a[i] == a[i + 1]) dp[i][i + 1] = 1;</span><br><span class="line">        else dp[i][i + 1] = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[n][n] = 1;</span><br><span class="line">    for (int i = 2; i &lt; n; i++) &#123;//长度</span><br><span class="line">        for (int j = 1; j + i &lt;= n; j++) &#123;//起点</span><br><span class="line">            for (int k = 0; k &lt; i; k++) &#123;</span><br><span class="line">                if (a[j] == a[j + i]) dp[j][i + j] = min(dp[j][i + j], dp[j][j + k] + dp[j + k + 1][j + i] - 1);</span><br><span class="line">                else dp[j][i + j] = min(dp[j][i + j], dp[j][j + k] + dp[j + k + 1][j + i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[1][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="背包dp">4.背包DP</h1>
<h2 id="a.bjoi2019-排兵布阵">A.[BJOI2019] 排兵布阵</h2>
<p><strong><em>小 C 正在玩一款排兵布阵的游戏。在游戏中有 <span
class="math inline">\(n\)</span>
座城堡，每局对战由两名玩家来争夺这些城堡。每名玩家有 <span
class="math inline">\(m\)</span> 名士兵，可以向第 <span
class="math inline">\(i\)</span> 座城堡派遣 <span
class="math inline">\(a_i\)</span>
名士兵去争夺这个城堡，使得总士兵数不超过 <span
class="math inline">\(m\)</span>。</em></strong></p>
<p><strong><em>如果一名玩家向第 <span class="math inline">\(i\)</span>
座城堡派遣的士兵数严格大于对手派遣士兵数的两倍，那么这名玩家就占领了这座城堡，获得
<span class="math inline">\(i\)</span> 分。</em></strong></p>
<p><strong><em>现在小 C 即将和其他 <span
class="math inline">\(s\)</span> 名玩家两两对战，这 <span
class="math inline">\(s\)</span> 场对决的派遣士兵方案必须相同。小 C
通过某些途径得知了其他 <span class="math inline">\(s\)</span>
名玩家即将使用的策略，他想知道他应该使用什么策略来最大化自己的总分。</em></strong></p>
<p><strong><em>由于答案可能不唯一，你只需要输出小 C
总分的最大值。</em></strong></p>
<p><strong><em>数据范围： <span class="math inline">\(1\le s \le
100\)</span> <span class="math inline">\(1\le n \le 100\)</span> <span
class="math inline">\(1\le m \le 20000\)</span> 对于每名玩家 <span
class="math inline">\(a_i \ge 0\)</span>，<span
class="math inline">\(\sum\limits_{i=1}^n a_i \le
m\)</span></em></strong></p>
<p>分组背包裸题，方程：</p>
<p><span class="math display">\[
dp[i][j] = \max(dp[i - 1][j],dp[i - 1][j - 2 * a[i].zu[k] - 1] + i * k)
(i\in[1,n],j\in[1,m],k\in[1,s])
\]</span></p>
<p>细节：每个组要先排序，严格大于意味着花费是两倍还要再加一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n,m,s;</span><br><span class="line">struct p</span><br><span class="line">&#123;</span><br><span class="line">    int hang;</span><br><span class="line">    int zu[120];</span><br><span class="line">&#125;a[120];</span><br><span class="line"></span><br><span class="line">int b[105][105];</span><br><span class="line"></span><br><span class="line">int dp[10001][10001];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">        for(int j = 1;j &lt;= s;j++)&#123;</span><br><span class="line">            int x;cin&gt;&gt;x;</span><br><span class="line">            b[i][j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j = 1;j &lt;= s;j++)&#123;</span><br><span class="line">        for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">            a[i].zu[j] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a[j].zu + 1,a[j].zu + s + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">        for(int j = m;j &gt;= 1;j--)&#123;</span><br><span class="line">            for(int k = 1;k &lt;= s;k++)&#123;</span><br><span class="line">                if(j &gt; 2 * a[i].zu[k]) dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - 2 * a[i].zu[k] - 1] + i * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.垃圾陷阱">B.垃圾陷阱</h2>
<p><strong><em>卡门――农夫约翰极其珍视的一条 <code>Holsteins</code>
奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为
<span class="math inline">\(D\)</span>（<span class="math inline">\(2
\le D \le 100\)</span>）英尺。</em></strong></p>
<p><strong><em>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</em></strong></p>
<p><strong><em>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</em></strong></p>
<p><strong><em>假设卡门预先知道了每个垃圾扔下的时间 <span
class="math inline">\(t\)</span>（<span class="math inline">\(1 \le t
\le 1000\)</span>），以及每个垃圾堆放的高度 <span
class="math inline">\(h\)</span>（<span class="math inline">\(1 \le h
\le 25\)</span>）和吃进该垃圾能维持生命的时间 <span
class="math inline">\(f\)</span>（<span class="math inline">\(1 \le f
\le
30\)</span>），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续
<span class="math inline">\(10\)</span> 小时的能量，如果卡门 <span
class="math inline">\(10\)</span> 小时内（不含 <span
class="math inline">\(10\)</span>
小时，维持生命的时间同）没有进食，卡门就将饿死。</em></strong></p>
<p><strong><em>第一行为两个整数，<span class="math inline">\(D\)</span>
和 <span class="math inline">\(G\)</span>（<span class="math inline">\(1
\le G \le 100\)</span>），<span class="math inline">\(G\)</span>
为被投入井的垃圾的数量。</em></strong></p>
<p><strong><em>第二到第 <span class="math inline">\(G+1\)</span>
行每行包括三个整数：<span class="math inline">\(T\)</span>（<span
class="math inline">\(1 \le T \le
1000\)</span>），表示垃圾被投进井中的时间；<span
class="math inline">\(F\)</span>（<span class="math inline">\(1 \le F
\le 30\)</span>），表示该垃圾能维持卡门生命的时间；和 <span
class="math inline">\(H\)</span>（<span class="math inline">\(1 \le H
\le 25\)</span>），该垃圾能垫高的高度。</em></strong></p>
<p>将<span
class="math inline">\(D\)</span>看作背包容量，用该高度与时间的最大体力当作状态，则题目变为在限制条件求下最快填满背包的时间，吃掉用刷表法，垫起来用填表法（这是因为填表不好初始化，且不好与吃掉同步）。吃掉的方程：</p>
<p><span class="math display">\[
dp[i][j] = \max(dp[i - 1][j] + n[i].f - n[i].t + n[i-1].t) \tag{1}
\]</span></p>
<p>垫起来的方程：</p>
<p><span class="math display">\[
dp[i][j + n[i].h] = \max(dp[i][j + n[i].h],dp[i - 1][j] - n[i].t +
n[i-1].t) \tag{2}
\]</span></p>
<p>转移条件：</p>
<p><span class="math display">\[
dp[i - 1][j] \ge n[i].t - n[i-1].t \tag{3}
\]</span></p>
<p>其中<span class="math inline">\(n[i]\)</span>为对<span
class="math inline">\(t\)</span>排序后的第<span
class="math inline">\(i\)</span>物品。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int d,g;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int t,f,h;</span><br><span class="line">&#125;n[10000];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">    return a.t&lt;b.t;</span><br><span class="line">&#125;</span><br><span class="line">int dp[150][150];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;d&gt;&gt;g;</span><br><span class="line">    for(int i=1;i&lt;=g;i++)&#123;</span><br><span class="line">        cin&gt;&gt;n[i].t&gt;&gt;n[i].f&gt;&gt;n[i].h;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(n+1,n+g+1,cmp);</span><br><span class="line">    dp[0][0] = 10;</span><br><span class="line">    memset(dp,-100,sizeof(dp));</span><br><span class="line">    dp[0][0] = 10;</span><br><span class="line">    int ans = -100000;</span><br><span class="line">    for(int i = 1;i&lt;=g;i++)&#123;</span><br><span class="line">        for(int j = d; j &gt;= 0;j--)&#123;</span><br><span class="line">            if(dp[i - 1][j] &lt; n[i].t - n[i-1].t) continue;</span><br><span class="line">            if(j + n[i].h &gt;= d)&#123;</span><br><span class="line">                cout&lt;&lt;n[i].t;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = max(dp[i][j],dp[i - 1][j] + n[i].f - n[i].t + n[i-1].t);//吃掉</span><br><span class="line">            dp[i][j + n[i].h] = max(dp[i][j + n[i].h],dp[i - 1][j] - n[i].t + n[i-1].t);//垫起来</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,n[i].t + dp[i][0]);</span><br><span class="line">    &#125;//体力一定要最多</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="c.noip2014-提高组-飞扬的小鸟">C.[NOIP2014 提高组]
飞扬的小鸟</h2>
<p><strong><em>Flappy Bird
是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。</em></strong></p>
<p><strong><em>为了简化问题，我们对游戏规则进行了简化和改编:</em></strong></p>
<p><strong><em>游戏界面是一个长为 <span
class="math inline">\(n\)</span>，高为 <span
class="math inline">\(m\)</span> 的二维平面，其中有 <span
class="math inline">\(k\)</span>
个管道（忽略管道的宽度）。</em></strong></p>
<p><strong><em>小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。</em></strong></p>
<p><strong><em>小鸟每个单位时间沿横坐标方向右移的距离为 <span
class="math inline">\(1\)</span>，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度
<span
class="math inline">\(x\)</span>，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度
<span
class="math inline">\(y\)</span>。小鸟位于横坐标方向不同位置时，上升的高度
<span class="math inline">\(x\)</span> 和下降的高度 <span
class="math inline">\(y\)</span> 可能互不相同。</em></strong></p>
<p><strong><em>小鸟高度等于 <span class="math inline">\(0\)</span>
或者小鸟碰到管道时，游戏失败。小鸟高度为 <span
class="math inline">\(m\)</span> 时，无法再上升。</em></strong></p>
<p><strong><em>现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。</em></strong></p>
<p><strong><em>第 <span class="math inline">\(1\)</span> 行有 <span
class="math inline">\(3\)</span> 个整数 <span class="math inline">\(n,
m,
k\)</span>，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；</em></strong></p>
<p><strong><em>接下来的 <span class="math inline">\(n\)</span> 行，每行
<span class="math inline">\(2\)</span> 个用一个空格隔开的整数 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>，依次表示在横坐标位置 <span
class="math inline">\(0 \sim n-1\)</span>
上玩家点击屏幕后，小鸟在下一位置上升的高度 <span
class="math inline">\(x\)</span>，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度
<span class="math inline">\(y\)</span>。</em></strong></p>
<p><strong><em>接下来 <span class="math inline">\(k\)</span> 行，每行
<span class="math inline">\(3\)</span> 个整数 <span
class="math inline">\(p,l,h\)</span>，每两个整数之间用一个空格隔开。每行表示一个管道，其中
<span class="math inline">\(p\)</span> 表示管道的横坐标，<span
class="math inline">\(l\)</span> 表示此管道缝隙的下边沿高度，<span
class="math inline">\(h\)</span> 表示管道缝隙上边沿的高度（输入数据保证
<span class="math inline">\(p\)</span>
各不相同，但不保证按照大小顺序给出）。</em></strong></p>
<p><strong><em>对于 <span class="math inline">\(100\%\)</span>
的数据：<span class="math inline">\(5 \leq n \leq 10000\)</span>，<span
class="math inline">\(5 \leq m \leq 1000\)</span>，<span
class="math inline">\(0 \leq k &lt; n\)</span>，<span
class="math inline">\(0 &lt; x,y &lt; m\)</span>，<span
class="math inline">\(0 &lt; p &lt; n\)</span>，<span
class="math inline">\(0 \leq l &lt; h \leq m\)</span>， <span
class="math inline">\(l + 1 &lt; h\)</span>。</em></strong></p>
<p>建模为两个背包：上升为完全背包，下降为01背包。</p>
<p>对于下降而言没什么坑点，但对于上升而言，必须特判到最顶点的情况，以及特判在初始时刻能从原点出发。</p>
<p>最后还要注意排序也有坑点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n, m, k;</span><br><span class="line">struct guan</span><br><span class="line">&#123;</span><br><span class="line">    int maxh, minh, x = 0x7ff;</span><br><span class="line">&#125; n1[10500];</span><br><span class="line">struct updown</span><br><span class="line">&#123;</span><br><span class="line">    int up, down;</span><br><span class="line">&#125; move1[10500];</span><br><span class="line">int ha[10500];</span><br><span class="line">int dp[10500][1050];</span><br><span class="line">bool cmp(guan a, guan b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.x &lt; b.x ? 1 : 0;</span><br><span class="line">&#125;</span><br><span class="line">int new_h[10500][1050];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    int cnt1 = 1;</span><br><span class="line">    memset(ha, 0, sizeof(ha));</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; move1[i].up &gt;&gt; move1[i].down;</span><br><span class="line">    for (int i = 1; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ha[x]++;</span><br><span class="line">        cin &gt;&gt; n1[i].minh &gt;&gt; n1[i].maxh;</span><br><span class="line">        n1[i].x = x;</span><br><span class="line">        cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(n1 + 1, n1 + k + 1, cmp);</span><br><span class="line">    memset(dp, 0x3f, sizeof(dp));</span><br><span class="line">    int cnt2 = 1;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        new_h[i][1] = move1[i].up;</span><br><span class="line">        int cnt = 2;</span><br><span class="line">        for (int j = 2; j * move1[i].up &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_h[i][cnt++] = j * move1[i].up;</span><br><span class="line">        &#125;</span><br><span class="line">        new_h[i][cnt] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!ha[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            for (int j = m - move1[i - 1].up; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">			    dp[i][m]=min(dp[i][m],min(dp[i][j],dp[i-1][j])+1);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][m] = min(dp[i - 1][m] + 1, dp[i][m]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ha[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            for (int j = m - move1[i - 1].up; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">			    dp[i][m]=min(dp[i][m],min(dp[i][j],dp[i-1][j])+1);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][m] = min(dp[i - 1][m] + 1, dp[i][m]);</span><br><span class="line">            int res = 0x3f3f3f3f;</span><br><span class="line">            for (int j = n1[cnt2].minh + 1; j &lt;= n1[cnt2].maxh - 1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res = min(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = 1; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!(j &gt;= n1[cnt2].minh + 1 &amp;&amp; j &lt;= n1[cnt2].maxh - 1))</span><br><span class="line">                    dp[i][j] = 0x3f3f3f3f;</span><br><span class="line">            &#125;</span><br><span class="line">            if (res &gt;= 0x3f3f3f3f)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; 0 &lt;&lt; endl</span><br><span class="line">                     &lt;&lt; cnt2 - 1;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0x7ffff;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">        ans = min(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; 1 &lt;&lt; endl</span><br><span class="line">         &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>奇奇怪怪的线代题(1)</title>
    <url>/2023/12/01/page-2/</url>
    <content><![CDATA[<h1 id="一些奇奇怪怪的线代题">一些奇奇怪怪的线代题</h1>
<h2 id="a.行列式">A.行列式</h2>
<p><em>1.计算<span class="math inline">\(n\)</span>阶行列式</em></p>
$$ D_n = |
<span class="math display">\[\begin{array}{cccc}
2\cos x &amp;1   &amp; 0 &amp; \dots &amp;0&amp;0\\
1 &amp;2\cos x &amp; 1 &amp; \dots &amp;0&amp;0\\
0 &amp;1 &amp;2\cos x &amp;  \dots &amp;0&amp;0\\

\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp; 0 &amp; \dots &amp;2\cos x&amp;1\\
0 &amp;0 &amp; 0 &amp; \dots &amp;1&amp;2 \cos x\\

\end{array}\]</span>
<p>|. $$</p>
<p>将其按第一行展开：</p>
$$ D_n = |
<span class="math display">\[\begin{array}{cccc}
2\cos x &amp;1   &amp; 0 &amp; \dots &amp;0&amp;0\\
1 &amp;2\cos x &amp; 1 &amp; \dots &amp;0&amp;0\\
0 &amp;1 &amp;2\cos x &amp;  \dots &amp;0&amp;0\\

\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp; 0 &amp; \dots &amp;2\cos x&amp;1\\
0 &amp;0 &amp; 0 &amp; \dots &amp;1&amp;2 \cos x\\

\end{array}\]</span>
| \=2x |
<span class="math display">\[\begin{array}{cccc}
2\cos x &amp;1    &amp; \dots &amp;0&amp;0\\
1 &amp;2\cos x  &amp; \dots &amp;0&amp;0\\
\vdots  &amp; \vdots &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp; \dots &amp;2\cos x&amp;1\\
0 &amp;0  &amp; \dots &amp;1&amp;2 \cos x\\
\end{array}\]</span>
| - |
<span class="math display">\[\begin{array}{cccc}
1 &amp;1   &amp; \dots &amp;0&amp;0\\
0 &amp;2\cos x  &amp; \dots &amp;0&amp;0\\
\vdots &amp; \vdots  &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp;  \dots &amp;2\cos x&amp;1\\
0 &amp;0 &amp;  \dots &amp;1&amp;2 \cos x\\
\end{array}\]</span>
<p>|\= 2D_{n-1} - D_{n-2} $$</p>
<p>因此<span
class="math inline">\(D_n\)</span>为二阶线性递推数列，求特征根得</p>
<p><span class="math display">\[
\lambda_1=\cos x + i\sin x,\lambda_2=\cos x-i\sin x
\]</span></p>
<p>结合<span class="math inline">\(D_1=2\cos x\)</span>以及<span
class="math inline">\(D_2 = 4\cos^2 x - 1\)</span>得</p>
<p><span class="math display">\[
D_n = \cos nx + \cot x\sin nx.
\]</span></p>
<hr />
<p><em>2.计算n阶行列式</em></p>
$$ D_n = |
<span class="math display">\[\begin{array}{cccc}
1 &amp;1 &amp; \dots &amp;1\\
x &amp;x &amp;\dots&amp;x\\
x^2 &amp;x^2&amp;\dots &amp;x^2\\

\vdots &amp; \vdots &amp; &amp; \vdots \\
x^{n-2} &amp;x^{n-2}&amp;\dots &amp;x^{n-2}\\
x^n &amp;x^n &amp; \dots &amp;x^n\\

\end{array}\]</span>
<p>|. $$</p>
<p>考虑<span class="math inline">\(n+1\)</span>阶范德蒙德行列式</p>
$$ |
<span class="math display">\[\begin{array}{cccc}
1 &amp;1 &amp; \dots &amp;1&amp;1\\
x &amp;x &amp;\dots&amp;x&amp;y\\
x^2 &amp;x^2&amp;\dots &amp;x^2&amp;y^2\\

\vdots &amp; \vdots &amp; &amp; \vdots &amp;\vdots\\
x^{n-2} &amp;x^{n-2}&amp;\dots &amp;x^{n-2}&amp;y^{n-2}\\
x^{n-1} &amp;x^{n-1}&amp;\dots &amp;x^{n-1}&amp;y^{n-1}\\

x^n &amp;x^n &amp; \dots &amp;x^n&amp;y^n\\

\end{array}\]</span>
<p>|=<em>{k=1}^n(y-x_k)</em>{1j&lt;in}(x_i-x_j) $$</p>
<p>按第<span class="math inline">\(n+1\)</span>列展开：</p>
<p><span class="math display">\[
D_{n+1} = A_{1,n+1} + yA_{2,n+1}+\dots +y^{n-1}A_{n,n+1}+y^nA_{n+1,n+1}
\]</span></p>
<p>并注意到</p>
<p><span class="math display">\[
A_{n,n+1} = -D_n
\]</span></p>
<p>以及</p>
<p><span class="math display">\[
\prod \limits_{k=1}^n(y-x_k) = y^n-y^{n-1}\sum_{k=1}^{n}x_k+\dots
+(-1)^n\prod_{k=1}^{n}x_k
\]</span></p>
<p>从而</p>
<p><span class="math display">\[
D_n = \sum_{k=1}^{n}x_k\prod_{1\le j&lt;i\le n}(x_i-x_j).
\]</span></p>
<hr />
<h2 id="b.证明题">B.证明题</h2>
<p><em>设<span class="math inline">\(\{\alpha _i\}\)</span>为<span
class="math inline">\(n-1\)</span>个线性无关的<span
class="math inline">\(n\)</span>维向量组，<span
class="math inline">\(\xi
_1,\xi_2\)</span>为与该向量组向量均正交的两个<span
class="math inline">\(n\)</span>维列向量，证明：<span
class="math inline">\(\xi _1,\xi_2\)</span>线性相关。</em></p>
<p>证明：将 $_1 $ 添入向量组中，考虑到正交即线性无关，包含 <span
class="math inline">\(\xi _1\)</span> 的向量组即为空间的一组基，并设
<span class="math inline">\(\xi_1\)</span> 在该组基下的坐标表示为<span
class="math inline">\((k_1,k_2,\dots k_n)\)</span>即有</p>
<p><span class="math display">\[
\xi_1 ^T\xi _2 =(\sum_{i=1}^{n-1}k_i\alpha_i^T+k_n\xi_2^T)\xi
_2=k_n\xi_2^T\xi_2
\]</span></p>
<p>以及</p>
<p><span class="math display">\[
\xi_1 ^T\xi _1 =(\sum_{i=1}^{n-1}k_i\alpha_i^T+k_n\xi_2^T)\xi
_1=k_n\xi_2^T\xi_1
\]</span></p>
<p>从而有</p>
<p><span class="math display">\[
\frac{\xi_1 ^T\xi _2 }{\xi_2^T\xi_2}=\frac{\xi _1^T \xi_1}{\xi_2^T\xi_1}
\]</span></p>
<p>写成内积的形式：</p>
<p><span class="math display">\[
||(\xi_1, \xi_2)||^2 =(||\xi_2||^2)(||\xi _1||^2)
\]</span></p>
<p>此即欧氏空间的柯西不等式等号成立的情况，当且仅当<span
class="math inline">\(\xi_1,\xi_2\)</span>线性相关。<span
class="math inline">\(\square\)</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>代数</tag>
        <tag>行列式</tag>
        <tag>柯西不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>数论笔记</title>
    <url>/2024/01/28/page-3/</url>
    <content><![CDATA[<h1 id="数论笔记不断更新">数论笔记（不断更新）</h1>
<h2 id="a">A</h2>
<p><strong><em>有一组给定的序列，构造一个数，使这个序列关于这个数的模有且仅有两个数。</em></strong></p>
<p><strong>结论：所求答案为：</strong></p>
<p><span class="math display">\[
ans = 2(a_2-a_1,a_3-a_2,\dots,a_n-a_{n-1})
\]</span></p>
<p><strong>证明：</strong></p>
<p>首先可以证明</p>
<p><span class="math display">\[
a_i \equiv a_j \pmod {(a_2-a_1,a_3-a_2,\dots,a_n-a_{n-1})}(\forall{i,j
\in[1,n]})
\]</span></p>
<p>设模值为 <span class="math inline">\(G=
(a_2-a_1,a_3-a_2,\dots,a_n-a_{n-1})\)</span>，并设</p>
<p><span class="math display">\[
a_i=p_iG+x \tag{A.1}
\]</span></p>
<p>考察 <span class="math inline">\(p_i\)</span> 的奇偶性，以下 <span
class="math inline">\(t\)</span> 为整数。若为奇数，便有</p>
<p><span class="math display">\[
a_i=(2t+1)G+x \rightarrow a_i \equiv G+x \pmod{2G}
\]</span></p>
<p>若为偶数，则有</p>
<p><span class="math display">\[
a_i=(2t)G+x \rightarrow a_i \equiv x \pmod{2G}
\]</span></p>
<p>下面证明任意序列 <span class="math inline">\(p_i\)</span>
必然不关于2同余。这是因为若关于2同余，那么对任意 <span
class="math inline">\(i,j \in [1,n]\)</span>，</p>
<p><span class="math display">\[
(p_i-p_j)|2
\]</span></p>
<p>利用<span class="math inline">\((1)\)</span>立得</p>
<p><span class="math display">\[
a_i - a_j=(p_i-p_j)G \rightarrow a_i - a_j\equiv 0 \pmod{2G}
\]</span></p>
<p>与所设 <span class="math inline">\(G\)</span> 矛盾，命题得证。<span
class="math inline">\(\square\)</span></p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛必达</title>
    <url>/2023/11/10/page/</url>
    <content><![CDATA[<h1 id="洛必达法则练习">洛必达法则练习</h1>
<hr />
<h2
id="求lim_xrightarrow-infty-fracexx100lim_nrightarrow-infty-fracenn100">1.求<span
class="math inline">\(\lim_{x\rightarrow +\infty}
\frac{e^{x}}{x^{100}}\)</span>；<span
class="math inline">\(\lim_{n\rightarrow +\infty}
\frac{e^{n}}{n^{100}}\)</span></h2>
<p><span class="math display">\[
\lim_{x\rightarrow +\infty} \frac{e^{x}}{x^{100}}\\=\lim_{x\rightarrow
+\infty} \frac{(e^{x})^{(100)}}{100!}=+\infty.
\]</span></p>
<p>由归结原则，数列极限也为0.</p>
<hr />
<h2
id="求lim_xrightarrow-infty-fracln20xxlim_nrightarrow-infty-fracln20nn">2.求<span
class="math inline">\(\lim_{x\rightarrow +\infty}
\frac{\ln^{20}(x)}{x}\)</span>;<span
class="math inline">\(\lim_{n\rightarrow +\infty}
\frac{\ln^{20}(n)}{n}\)</span></h2>
<p><span class="math display">\[
\lim_{x\rightarrow +\infty} \frac{\ln^{20}(x)}{x}\\=\lim_{x\rightarrow
+\infty} \frac{(\ln^{20}(x))^{&#39;}}{1}=\lim_{x\rightarrow
+\infty}(20/x)\ln^{19}(x)
\]</span></p>
<p>重复求导易得极限为0.</p>
<hr />
<h2 id="求lim_xrightarrow-0-frac113xa-12xa-1xax2">3.求<span
class="math inline">\(\lim_{x\rightarrow 0}
\frac{1+(1+3x)^{a}-(1+2x)^{a}-(1+x)^{a}}{x^{2}}\)</span></h2>
<p><span class="math display">\[
\lim_{x\rightarrow 0}
\frac{1+(1+3x)^{a}-(1+2x)^{a}-(1+x)^{a}}{x^{2}}\\=\lim_{x\rightarrow 0}
\frac{3a(1+3x)^{a-1}-2a(1+2x)^{a-1}-a(1+x)^{a-1}}{2x}\\=\lim_{x\rightarrow
0}
\frac{9a(a-1)(1+3x)^{a-2}-4a(a-1)(1+2x)^{a-2}-a(a-1)(1+x)^{a-2}}{2}\\=(9a^{2}-9a-4a^{2}+4a-a^{2}+a)/2=2a^{2}-2a.
\]</span></p>
<hr />
<h2 id="若-lim_xrightarrow-0-fracln-x-lnsin-xax21求aa不为0">4.若 <span
class="math inline">\(\lim_{x\rightarrow 0^{+}} \frac{\ln x-\ln(\sin
x)}{ax^{2}}=1\)</span>，求a(a不为0)</h2>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} \frac{\ln{x}-\ln(\sin
x)}{ax^{2}}\\=\lim_{x\rightarrow 0^{+}} \frac{\ln{(x/\sin
x)}}{ax^{2}}\\=\lim_{x\rightarrow 0^{+}}\frac{(x-\sin x)/\sin x}{ax^{2}}
\tag{1}
\]</span></p>
<p>将<span class="math inline">\(\sin x\)</span>展开到第二项即得</p>
<p><span class="math display">\[
{(x\rightarrow 0^{+})} \frac{x-\sin x}{x} \sim \frac{x^{2}}{6}
\]</span></p>
<p>代入<span class="math inline">\((1)\)</span>即得</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} \frac{\ln x-\ln(\sin
x)}{ax^{2}}=\frac{1}{6a}=1 \Rightarrow a= \frac{1}{6}.
\]</span></p>
<hr />
<h2 id="证明lim_xrightarrow-0-fracxxxx1.">5.证明：<span
class="math inline">\(\lim_{x\rightarrow 0^{+}}
\frac{x^{x^{x}}}{x}=1\)</span>.</h2>
<p>设<span class="math inline">\(k\)</span>为正数，则</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} x\ln^{k}{x}=\lim_{x\rightarrow
0^{+}}\frac{\ln^{k}{x}}{1/x}=\lim_{x\rightarrow
0^{+}}\frac{k\ln^{k-1}{x}}{-1/x^{3}}
\]</span></p>
<p>连续求导得</p>
<p><span class="math display">\[
lim_{x\rightarrow 0^{+}}\frac{k\ln^{k-1}{x}}{-1/x^{3}}=lim_{x\rightarrow
0^{+}}\frac{\prod_{i=1}^{[k]}(i+k-[k])\ln^{k-[k]}{x}}{-1/x^{1+2[k]}}
\tag{1}
\]</span></p>
<p>再对<span
class="math inline">\((1)\)</span>上下求一次导即得极限为0.</p>
<p>从而</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} \ln{x}(x^{x}-1)\\=\lim_{x\rightarrow 0^{+}}
\ln x(e^{x\ln{x}}-1)\\=\lim_{x\rightarrow 0^{+}} \ln x(x\ln x) =0.
\]</span></p>
<p>进而有</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}}
\frac{x^{x^{x}}}{x}=\lim_{x\rightarrow0^{+}}e^{\ln
x(x^{x}-1)}=1.~~~\square
\]</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>分析</tag>
        <tag>极限</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式笔记</title>
    <url>/2024/01/29/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="多项式笔记随缘更新">多项式笔记（随缘更新）</h1>
<h2 id="基础部分">基础部分</h2>
<h3 id="a.反演">A.反演</h3>
<p><strong>定义A.1：称函数 <span class="math inline">\(F(i)\)</span>
由另一函数 <span class="math inline">\(G(i)\)</span> 表出的运算 <span
class="math inline">\(f\)</span></strong></p>
<p><span class="math display">\[
F(i)=f(G(i))
\]</span></p>
<p><strong>为 <span class="math inline">\(F(i)\)</span> 关于 <span
class="math inline">\(G(i)\)</span> 的演绎，运算 <span
class="math inline">\(f^{-1}\)</span></strong></p>
<p><span class="math display">\[
G(i)=f^{-1}(F(i))
\]</span></p>
<p><strong>为 <span class="math inline">\(F(i)\)</span> 关于 <span
class="math inline">\(G(i)\)</span> 的反演.</strong></p>
<p>关于逆运算的存在性，在这里不严格证明。</p>
<p>计算机中主要应用的反演是离散的，上式中 <span
class="math inline">\(F\)</span> 和 <span
class="math inline">\(G\)</span> 通常以数列形式出现，<span
class="math inline">\(f\)</span> 通常会是线性算子：</p>
<p><span class="math display">\[
F_i=\sum_{j=0}^{i}A_{i,j}G_i\tag{1}
\]</span></p>
<p><span class="math display">\[
G_i=\sum_{j=0}^{i}B_{i,j}F_i\tag{1&#39;}
\]</span></p>
<p>演绎与反演也会有积分形式（例如傅里叶变换和傅里叶反演），但并不在本节讨论的范围内.因此(1)也可以写作矩阵形式</p>
<p><span class="math display">\[
(F_1,F_2,\dots,F_n)^T=\textbf{A}(G_1,G_2,\dots,G_n)^T
\]</span></p>
<p>(2)同理.</p>
<p><strong>定义A.2：定义1中的 <span
class="math inline">\(\textbf{A},\)</span> <span
class="math inline">\(\textbf{B}\)</span>
分别称作演绎矩阵、反演矩阵.</strong></p>
<p>由矩阵形式不难看出</p>
<p><strong>性质A.1：演绎矩阵、反演矩阵互逆.</strong></p>
<p>例A.1：给定一个数列 <span class="math inline">\({A_n}\)</span>
，其前缀和与差分运算互为反演。具体地有：</p>
<p><span class="math display">\[
(S_1,S_2,\dots,S_n)^T = \left (\begin{array}{cccc}1 &amp;0  &amp; 0
&amp; \dots &amp;0&amp;0\\1 &amp;1 &amp; 0 &amp; \dots
&amp;0&amp;0\\\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots &amp;
\vdots \\1 &amp;1 &amp; 1 &amp; \dots &amp;1 &amp;0\\1 &amp;1 &amp; 1
&amp; \dots &amp;1&amp;1\\\end{array}\right)_{n}(A_1,A_2,\dots,A_n)^T
\]</span></p>
<p>为前缀和，</p>
<p><span class="math display">\[
(A_1,A_2,\dots,A_n)^T = \left (\begin{array}{cccc}1 &amp;0  &amp; 0
&amp; \dots &amp;0&amp;0\\-1 &amp;1 &amp; 0 &amp; \dots &amp;0&amp;0\\0
&amp; -1 &amp; 1 &amp; \dots &amp;0&amp;0\\\vdots &amp; \vdots &amp;
\vdots &amp; &amp;\vdots &amp;\vdots \\0 &amp;0 &amp; 0 &amp; \dots
&amp;-1&amp;1\\\end{array}\right)_{n}(S_1,S_2,\dots,S_n)^T
\]</span></p>
<p>为差分.不难验证</p>
<p><span class="math display">\[
\left (\begin{array}{cccc}1 &amp;0  &amp; 0 &amp; \dots &amp;0&amp;0\\1
&amp;1 &amp; 0 &amp; \dots &amp;0&amp;0\\\vdots &amp; \vdots &amp;
\vdots &amp; &amp;\vdots &amp; \vdots \\1 &amp;1 &amp; 1 &amp; \dots
&amp;1  &amp;0\\1 &amp;1 &amp; 1 &amp; \dots
&amp;1&amp;1\\\end{array}\right)\left (\begin{array}{cccc}1
&amp;0  &amp; 0 &amp; \dots &amp;0&amp;0\\-1 &amp;1 &amp; 0 &amp; \dots
&amp;0&amp;0\\0 &amp; -1 &amp; 1 &amp; \dots &amp;0&amp;0\\\vdots &amp;
\vdots &amp; \vdots &amp; &amp;\vdots &amp; \vdots \\0 &amp;0 &amp; 0
&amp; \dots &amp;-1&amp;1\\\end{array}\right) = \textbf{E}.
\]</span></p>
<p><strong>性质A.2：反演中系数可以转移.</strong></p>
<p><strong>性质A.3：反演矩阵、演绎矩阵转置后，将求和从向下至下界变为向上至上界，反演关系仍然存在.</strong></p>
<p>对于性质2，可以由矩阵逆性质简单得出.
对于性质3，根据定义，演绎矩阵必然是三角阵，根据线性代数，三角阵的转置的逆等于原三角阵逆的转置.</p>
<p>例A.2（二项式反演）：</p>
<p><span class="math display">\[
F_n=\sum_{i=0}^{n}(-1)^i{n \choose i} G_n\iff G_n=\sum_{i=0}^{n}(-1)^i{n
\choose i} F_n
\]</span></p>
<p>证明：此处不用容斥证明.直接将下三角阵 <span
class="math inline">\(\textbf{A}_{i,j}=(-1)^n {n \choose i}\)</span>
平方计算便可得到需要的结果. <span
class="math inline">\(\square\)</span></p>
<p>常见的形式是将 <span class="math inline">\((-1)^i\)</span>
移至一边，即</p>
<p><span class="math display">\[
F_n=\sum_{i=0}^{n}{n \choose i} G_n\iff G_n=\sum_{i=0}^{n}(-1)^{n-i}{n
\choose i} F_n \tag{2}
\]</span></p>
<p>这种形式在组合数学的意义是已知使用 <span
class="math inline">\(n\)</span> 个数中某 <span
class="math inline">\(i\)</span>
个数构成特殊结构的组合方案的总合下，求出用 <span
class="math inline">\(i\)</span>
个数构成某种特殊结构的方案数.最典型的案例是错位排列数.一般来说，反演的用处就是将题给条件适当放大直到能求出解后对解进行反演.</p>
<hr />
<h3 id="b.生成函数基础">B.生成函数基础</h3>
<p><strong>定义B.1：给定一个数列 <span
class="math inline">\(A_i\)</span> ，称</strong></p>
<p><span class="math display">\[
A(x)= \sum_{i=0}^{\infty} A_ix^i\tag{3}
\]</span></p>
<p><strong>为 <span class="math inline">\(A_i\)</span>
的生成函数或形式幂级数环.</strong></p>
<p>容易看出，生成函数都是多项式，可以对其进行多项式能进行的操作：</p>
<ol type="1">
<li>加法，满足交换律</li>
<li>乘法，满足结合律、交换律</li>
<li>复合，满足结合律</li>
<li>微商，满足一元函数求导的性质</li>
<li>乘逆元，对 <span class="math inline">\(f^{-1}\)</span>
作泰勒展开</li>
</ol>
<p>由于泰勒展开的存在，如果得知一个数列的递推式，用生成函数可以求它的通项.</p>
<p>例B.1：求贝尔数</p>
<p><span class="math display">\[
B_{n+1}=\sum_{i=0}^{n} {n\choose i}B_i,B_0=1
\]</span></p>
<p>的通项公式.</p>
<p>设其指数生成函数为</p>
<p><span class="math display">\[
B(x)= \sum_{i=0}^{\infty} \frac{B_i}{i!}x^i=1+\sum_{i=0}^{\infty}
\frac{B_{i+1}}{(i+1)!}x^{i+1}\tag{4}
\]</span></p>
<p>其微商为</p>
<p><span class="math display">\[
B&#39;(x)=\sum_{i=0}^{\infty} B_ix^{i+1}
\]</span></p>
<p>由递推式得</p>
<p><span class="math display">\[
\frac{B_{n+1}}{n!}=\sum_{i=0}^{n}\frac{B_i}{i!}\frac{1}{(n-i)!}
\]</span></p>
<p>将 <span class="math inline">\(e^x\)</span>
的级数展开对应上式，即得</p>
<p><span class="math display">\[
B(x)=e^xB&#39;(x)
\]</span></p>
<p>这是一个一阶微分方程，变形得</p>
<p><span class="math display">\[
\frac{\mathrm dB}{B}=e^{-x}dx
\]</span></p>
<p>两边积分即得</p>
<p><span class="math display">\[
B(x)=\exp(e^x+C)
\]</span></p>
<p>代入边界条件即得 <span class="math inline">\(C=-1\)</span> ,于是</p>
<p><span class="math display">\[
B(x)=\exp(e^x-1) \tag{5}
\]</span></p>
<p>便是贝尔数的生成函数封闭形式.</p>
<p>将其第一层泰勒展开，</p>
<p><span class="math display">\[
B(x)=\frac{1}{e}(\sum_{i=0}^{\infty}\frac{1}{i!}e^{ix})
\]</span></p>
<p>第二层展开，</p>
<p><span class="math display">\[
B(x)=\frac{1}{e}(\sum_{i=0}^{\infty}\frac{1}{i!}e^{ix})\\=\frac{1}{e}(\sum_{i=0}^{\infty}\frac{1}{i!}\sum
_{j=0}^{\infty}\frac{1}{j!}(ix)^j)
\]</span></p>
<p>对比<span
class="math inline">\((4)\)</span>，考虑到生成函数在正数上良定义，可以交换求和顺序，用
<span class="math inline">\(n\)</span> 替换 <span
class="math inline">\(j\)</span> 便可得出通项公式</p>
<p><span class="math display">\[
B_n=\frac{1}{e}\sum_{i=0}^{\infty}\frac{i^n}{i!}\tag{6}
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<hr />
<h3 id="c.拉格朗日插值法">C.拉格朗日插值法</h3>
<p>对于已知序列 <span class="math inline">\(X_i=f(x_i)\)</span>
，考虑还原出原多项式.</p>
<p>首先，关于复数域上 <span class="math inline">\(n\)</span>
个多项式根能否确定一个 <span class="math inline">\(n\)</span>
次多项式，需要由代数基本定理给出.</p>
<p><strong>定理（代数基本定理）：任何复系数一元 <span
class="math inline">\(n\)</span> 次多项式（<span
class="math inline">\(n\)</span> 至少为
1）方程在复数域上至少有一根.</strong></p>
<p>该定理证明较为复杂，且与本节所述内容无太大关系，因此将其作为结论使用，证明将会留在附录给出.下面我们将得出本节最重要的成果</p>
<p><strong>定理C.1（拉格朗日插值法）：数域 $ $ 上一个次数不超过 <span
class="math inline">\(n\)</span> 的多项式 <span
class="math inline">\(f(x)\)</span>，被它在 $ $ 中的 <span
class="math inline">\(n+1\)</span> 个不同元素 <span
class="math inline">\(x_i\)</span> 的函数值 <span
class="math inline">\(y_i=f(x_i)\)</span> 所唯一确定</strong></p>
<p><span class="math display">\[
f(x)=\sum_{i=0}^{n}y_i\prod_{j=0,j\neq i}^n\frac{(x-x_j)}{(x_i-x_j)}
\tag{8}
\]</span></p>
<p>证明：</p>
<p>1）唯一性证明 考虑演绎</p>
<p><span class="math display">\[
(y_0,y_1,\dots,y_n)^T=\left (\begin{array}{cccc}1&amp; x_0 &amp; \dots
&amp;x_{0}^{n-1}&amp;x_0^n\\1&amp; x_1 &amp; \dots
&amp;x_{1}^{n-1}&amp;x_1^n\\ \vdots &amp; \vdots &amp; &amp;\vdots
&amp;\vdots \\1&amp; x_n &amp; \dots
&amp;x_{n}^{n-1}&amp;x_n^n\\\end{array}\right)(a_0,a_1,\dots,a_n)^T
\tag{9}
\]</span></p>
<p>为每个函数值对应系数的矩阵表示，注意到演绎矩阵 <span
class="math inline">\(\textbf{V}\)</span> 为范德蒙德矩阵，有如下引理</p>
<p><strong>引理C.1：对于范德蒙德行列式，有如下结论</strong></p>
<p><span class="math display">\[
|\textbf{V}|= \left |\begin{array}{cccc}1&amp; x_0 &amp; \dots
&amp;x_{0}^{n-1}&amp;x_0^n\\1&amp; x_1 &amp; \dots
&amp;x_{1}^{n-1}&amp;x_1^n\\ \vdots &amp; \vdots &amp; &amp;\vdots
&amp;\vdots \\1&amp; x_n &amp; \dots
&amp;x_{n}^{n-1}&amp;x_n^n\\\end{array}\right|=\prod_{0\leq i&lt;j\leq
n}(x_j-x_i)
\]</span></p>
<p>证明留在附录给出.</p>
<p>将 <span class="math inline">\((9)\)</span> 看作线性方程组，由于
<span class="math inline">\(x_i\)</span> 互不相等，范德蒙德行列式不为
<span
class="math inline">\(0\)</span>，根据<strong>克拉默法则</strong>，方程有且仅有唯一解.唯一性得证.</p>
<p>2）必要性显然</p>
<p>3）充分性证明 根据克拉默法则，<span
class="math inline">\((9)\)</span> 的解为</p>
<p><span class="math display">\[
a_i=\frac{|\textbf{V}_{i}|}{|\textbf{V}|},i=0,1,\dots,n
\]</span></p>
<p>其中 <span class="math inline">\(|\textbf{V}_{i}|\)</span>
为将原矩阵次数为 <span class="math inline">\(i\)</span> 的列替换为 <span
class="math inline">\((y_0,y_1,\dots,y_n)^T\)</span>
的行列式.因此我们有</p>
<p><span class="math display">\[
f(x)=\sum_{i=0}^n\frac{|\textbf{V}_{i}|}{|\textbf{V}|}x^i
\]</span></p>
<p>我们将 <span class="math inline">\(|\textbf{V}_{i}|\)</span>
按被替换的那列展开，即有</p>
<p><span class="math display">\[
|\textbf{V}_{i}|=\sum_{j=0}^ny_j |\textbf{V}_{ji}|
\]</span></p>
<p>其中 <span class="math inline">\(|\textbf{V}_{ji}|\)</span>
为代数余子式.因此</p>
<p><span class="math display">\[
f(x)=\sum_{i=0}^n\frac{|\textbf{V}_{i}|}{|\textbf{V}|}x^i=\sum_{i=0}^n\frac{\sum_{j=0}^ny_j
|\textbf{V}_{ji}|}{|\textbf{V}|}x^i=\frac{1}{|\textbf{V}|}\sum_{j=0}^ny_j\sum_{i=0}^nx^i|\textbf{V}_{ji}|
\]</span></p>
<p>其中后项关于 <span class="math inline">\(i\)</span>
的求和事实上是将范德蒙德行列式</p>
<p><span class="math display">\[
\left |\begin{array}{cccc}1&amp; x_0 &amp; \dots
&amp;x_{0}^{n-1}&amp;x_0^n\\1&amp; x_1 &amp; \dots
&amp;x_{1}^{n-1}&amp;x_1^n\\ \vdots &amp; \vdots &amp; &amp;\vdots
&amp;\vdots \\1&amp; x_n &amp; \dots
&amp;x_{n}^{n-1}&amp;x_n^n\\\end{array}\right|
\]</span></p>
<p>第 <span class="math inline">\(j + 1\)</span> 行按照将 <span
class="math inline">\(x_j^i\)</span> 替换为 <span
class="math inline">\(x^i\)</span> 的另一范德蒙德行列式，因此由引理1</p>
<p><span class="math display">\[
\sum_{i=0}^nx^i|\textbf{V}_{ji}|=\prod_{0\leq p &lt;q\leq n}^{p,q\neq
j}(x_q-x_p)\prod_{0\leq r \leq n}^{r \neq j}(x-x_r)
\]</span></p>
<p>从而</p>
<p><span class="math display">\[
f(x)=\frac{1}{|\textbf{V}|}\sum_{j=0}^ny_j\sum_{i=0}^nx^i|\textbf{V}_{ji}|=\sum_{j=0}^ny_j\frac{\prod_{1\leq
p &lt;q\leq n}^{p,q\neq j}(x_q-x_p)\prod_{1\leq r \leq n}^{r \neq
j}(x-x_r)}{\prod_{1\leq p&lt;q\leq
n}(x_q-x_p)}\\=\sum_{i=0}^{n}y_i\prod_{j=0,j\neq
i}^n\frac{(x-x_j)}{(x_i-x_j)} .
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<p>代码先咕着（</p>
<hr />
<h3 id="d.快速多项式乘法">D.快速多项式乘法</h3>
<p>快速傅里叶变换算法可以在 <span class="math inline">\(O(n \log
n)\)</span> 时间内求出两个多项式的乘积.</p>
<p>首先阐述卷积定义以方便下文叙述.</p>
<p><strong>定义D.1：将关于两个可积函数 <span
class="math inline">\(f(x),g(x)\)</span>
的生成一个新函数的运算</strong></p>
<p><span class="math display">\[
h(x)= \int_{-\infty}^{+\infty}f(x- t)g(x)dt \tag{7}
\]</span></p>
<p><strong>称为函数的卷积运算，记作</strong></p>
<p><span class="math display">\[
h(x)=f(x)*g(x)
\]</span></p>
<p>此处的函数可以是离散函数，将积分变为求和即可.</p>
<p>考察两个多项式</p>
<p><span class="math display">\[
f(x)=\sum_{i=0}^{n}a_ix^i,g(x)=\sum_{i=0}^{n}b_ix^i
\]</span></p>
<p>若想求出两多项式的乘积 <span
class="math inline">\(h(x)=f(x)g(x)\)</span> 的<strong>系数</strong>
<span
class="math inline">\({c_i}\)</span>，朴素的想法是直接将括号打开，一个对着另一个乘，即</p>
<p><span class="math display">\[
c_kx^k=\sum_{i=0}^{k}a_{k-i}x^{k-i}g_{i}x^i \tag{7&#39;}
\]</span></p>
<p>这事实上正是对 <span class="math inline">\(a_i,b_i\)</span>
进行卷积操作，那么我们便可以有朴素的 <span
class="math inline">\(O(n^2)\)</span> 算法求出 <span
class="math inline">\(c_i\)</span> .</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int N = 200050;</span><br><span class="line">int f[2 * N],g[N],c[N];</span><br><span class="line"></span><br><span class="line">void conv()&#123;</span><br><span class="line">	for(int i = 0;i &lt;= N;i++)&#123;</span><br><span class="line">        	for(int j = 0;j &lt;= N;j++)&#123;</span><br><span class="line">            		c[i + j] += g[i] * f[i];</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样的算法可行但效率不高，下面分两部分来介绍优化过程.</p>
<h4 id="离散傅里叶变换dft">1.离散傅里叶变换（DFT）</h4>
<p>DFT的核心思想是用<strong>函数值还原系数</strong>.</p>
<p>如果我们已知一个多项式的函数值，利用拉格朗日插值法可以在已知函数值和点值的情况下求出原函数的系数，下面考虑一种性质非常好的插值</p>
<p><strong>定理D.1（DFT）：对于演绎</strong></p>
<p><span class="math display">\[
X_k=\sum_{i=0}^{n-1}a_i\omega_n^{ik} \tag{10}
\]</span></p>
<p><strong>其反演为</strong></p>
<p><span class="math display">\[
a_k=\frac{1}{n}\sum_{i=0}^{n-1}X_i\omega_n^{-ik} \tag{10&#39;}
\]</span></p>
<p>其中 <span class="math inline">\(\omega_n\)</span> 表示方程 <span
class="math inline">\(x^n=-1\)</span> 的单位根.我们将 <span
class="math inline">\((8)\)</span> 称为离散傅里叶变换，<span
class="math inline">\((8&#39;)\)</span> 称为逆离散傅里叶变换.</p>
<p>该定理在多项式上的意义是把 <span class="math inline">\(n\)</span>
次单位根带进了多项式里，得到了 <span class="math inline">\(n\)</span>
个值，进而反求出系数.</p>
<p>证明：</p>
<p><span class="math display">\[
\frac{1}{n}\sum_{i=0}^{n-1}X_i\omega_n^{-ik}\\=\frac{1}{n}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\omega_n^{ij}\omega_n^{-ik}\\=\frac{1}{n}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\omega_n^{i(j-k)}
\]</span></p>
<p>若 <span class="math inline">\(j=k\)</span>，显然总贡献值为 <span
class="math inline">\(na_i\)</span>；</p>
<p>若 <span class="math inline">\(j\neq k\)</span>，贡献为</p>
<p><span class="math display">\[
\sum_{i=0}^{n-1}\omega_n^{i(j-k)}a_{j-k+k}=0
\]</span></p>
<p>从而推论成立.<span class="math inline">\(\square\)</span></p>
<p>这样的插值正逆极度对称，可以用相同的方法计算.</p>
<h4 id="多项式分治">2.多项式分治</h4>
<p>继续考虑单位根插值，我们考虑将多项式补成 <span
class="math inline">\(2^n\)</span>
次项后按<strong>奇偶分治</strong>，设</p>
<p><span class="math display">\[
FL(x)=\sum_{i=0}^{n/2-1}a_{2i}x^i,FR(x)=\sum_{i=1}^{ n/2-1}a_{2i}x^i
\]</span></p>
<p>即有</p>
<p><span class="math display">\[
f(x)=FL(x^2)+xFR(x^2)
\]</span></p>
<p>将单位根代入，不难推出如下分治</p>
<p><span class="math display">\[
f(\omega_n^k)=FL(\omega_n^{2k})+\omega_n^{k}FR(\omega_n^{2k}),\\f(\omega_n^{k/2+n})=FL(\omega_n^{2k})-\omega_n^kFR(\omega_n^{2k}),k\in[0,\frac{n}{2})
\tag{11}
\]</span></p>
<p>这允许我们在 <span class="math inline">\(O(n\log n)\)</span>
复杂度下求出 <span class="math inline">\(f\)</span> 的 <span
class="math inline">\(n\)</span>
个单位根点值表示.具体地，将大的区间不断按奇偶分半递归，回溯时更新原函数值.</p>
<h4 id="最终实现">3.最终实现</h4>
<p>终于可以回到多项式乘法了.</p>
<p>算法流程很简单：将所给多项式 <span class="math inline">\(f,g\)</span>
分治求出单位根点值，将多项式点值对应相乘后用逆 DFT 还原系数.</p>
<p>代码以洛谷P3803为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">complex&lt;double&gt; f[5000050],g[5000050];</span><br><span class="line">complex&lt;double&gt; tmp[5000050];</span><br><span class="line">int tag[5000050];</span><br><span class="line">void dft(complex&lt;double&gt; *ff,int n,int flg)&#123;</span><br><span class="line">    if(n == 1) return;</span><br><span class="line">    for(int i = 0;i &lt; n;i++)tmp[i] = ff[i];</span><br><span class="line">    for(int i = 0;i &lt; n;i++)&#123;</span><br><span class="line">        if(i &amp; 1) ff[n / 2 + i / 2] = tmp[i];</span><br><span class="line">        else ff[i / 2] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    complex&lt;double&gt; *q = ff,*p = ff + n / 2;</span><br><span class="line">    dft(q,n/2,flg),dft(p,n/2,flg);</span><br><span class="line">    complex&lt;double&gt; cur(1,0),step(cos(2 * PI/ n) ,sin(2 * PI * flg / n));</span><br><span class="line">    for(int k = 0;k &lt; n / 2;k++)&#123;</span><br><span class="line">        tmp[k] = q[k] + cur * p[k];</span><br><span class="line">        tmp[k + n / 2] = q[k] - cur * p[k];</span><br><span class="line">        cur *= step;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0;i &lt; n;i++)ff[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    int n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i = 0;i &lt;= n;i++)&#123;int x;cin&gt;&gt;x;f[i] = x;&#125;</span><br><span class="line">    for(int j = 0;j &lt;= m;j++)&#123;int x;cin&gt;&gt;x;g[j] = x;&#125;</span><br><span class="line">    int t = 1;</span><br><span class="line">    while(t &lt; n + m + 2) t&lt;&lt;=1;</span><br><span class="line">    dft(f,t,1),dft(g,t,1);</span><br><span class="line">    for(int i = 0;i &lt; t;i++) f[i] = f[i] * g[i];</span><br><span class="line">    dft(f,t,-1);</span><br><span class="line">    int flg = 1;</span><br><span class="line">    for(int i = 0;i &lt;= m + n;i++)cout&lt;&lt;int(f[i].real() / t + 0.50)&lt;&lt;&quot; &quot;;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是基础的快速多项式乘法的分治写法.</p>
]]></content>
      <tags>
        <tag>多项式 代数</tag>
      </tags>
  </entry>
  <entry>
    <title>做题笔记 2023/11/8</title>
    <url>/2023/11/08/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0-2023-11-8/</url>
    <content><![CDATA[<h1 id="做题笔记-2023118">做题笔记 2023/11/8</h1>
<h3 id="a.依赖背包-noip2006-金明的预算方案">A.依赖背包 [NOIP2006
金明的预算方案]</h3>
<p><strong><em>Q:有<span class="math inline">\(n\)</span>元钱，想买<span
class="math inline">\(m\)</span>个物品，第<span
class="math inline">\(i\)</span>个物品的价格为<span
class="math inline">\(v_{i}\)</span>，重要度为<span
class="math inline">\(p_{i}\)</span>，有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主件。目标是让所有购买的物品的<span
class="math inline">\(v_{i}p_{i}\)</span>之和最大。</em></strong></p>
<p>考虑将每个物品与其子类的各种组合看成另一些物品，先不将子类存在应遍历的数据里，在
dp 到父类时遍历一遍物品的子类与其的组合。</p>
<p>例如：3 物品有两个子类 7 、8 ，先不将 7 8 放入要查的数组里，查到 3
时再查 7 8，总共有 3 、3 7 、3 8 、3 7 8
四种取法，遍历子类组合时将组合里所有的 <span
class="math inline">\(v\)</span> 和 <span
class="math inline">\(vp\)</span> 加起来看作一个新物品。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0X7FFF;</span><br><span class="line">int n,m;</span><br><span class="line">int dp[N];</span><br><span class="line">pair&lt;int,int&gt; p1[N];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; s[N]; /*（其实写之前不知道 vector 有这个用法，想用两个数组来着）*/</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int v,p,q;cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;</span><br><span class="line">        p *=v;</span><br><span class="line">        if(!q)p1[i]=&#123;v,p&#125;;</span><br><span class="line">        else s[q].push_back(&#123;v,p&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        for(int j=n;j&gt;=0;j--)&#123;</span><br><span class="line">            for(int t=0;t&lt;1&lt;&lt;s[i].size();t++)&#123;</span><br><span class="line">                int v=p1[i].first;</span><br><span class="line">                int w=p1[i].second;</span><br><span class="line">                for(int z=0;z&lt;s[i].size();z++)&#123;</span><br><span class="line">                    if(t&gt;&gt;z &amp; 1)&#123;</span><br><span class="line">                        v+=s[i][z].first;</span><br><span class="line">                        w+=s[i][z].second;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j&gt;=v) dp[j]=max(dp[j],dp[j-v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.分治计算几何-平面最近点对-luogu-p1429">B.分治+计算几何
[平面最近点对 Luogu P1429]</h2>
<p><strong><em>Q:给出<span
class="math inline">\(R^{2}\)</span>上的一些点，搜出这些点中最小的距离。</em></strong></p>
<p><del>爆搜即可</del> 乍一看无从下手
<del>确实无从下手</del>，但是仔细想想，有点像区间dp（能量项链）：先将这些点按横坐标排序，再将其不断二分成两个或一个点的集合：<span
class="math inline">\((x_{1},x_{2})\)</span>、<span
class="math inline">\((x_{3},x_{4})\)</span>
……如果集合只有一个点将其值设置为无穷，有两个则设置为两点距离。接着进行合并，合并时除了先求出原先两个区间的最小值中的更小值之外，只需要再考虑跨越右区间左端
<span class="math inline">\(mid\)</span>或左区间右端 <span
class="math inline">\(mid+1\)</span>
的相互“比较近”的点，与上面求出的更小值进行比较即可。（如果全部点都遍历一遍复杂度就变成<span
class="math inline">\(O(nlogn)\)</span>了，必t）</p>
<p>那么问题就落到怎么定义“比较近”了。注意到在平面中：</p>
<p><span class="math display">\[
A:(x_{A}-x_{B}&gt;m) \vee B:(y_{A}-y_{B}&gt;m) \Rightarrow d(A,B)&gt;m
\\
\]</span></p>
<p>由于是横向分割，关于 <span class="math inline">\((mid)\)</span>
不满足 <span class="math inline">\(A\)</span> 的的点互相不满足 <span
class="math inline">\(A\)</span> ，且落在一个横向距离为 <span
class="math inline">\(2m\)</span>
，纵向无线延长的条带上，而遍历条带中的点对组合时，先考察一遍 <span
class="math inline">\(B\)</span> 性质代替 <span
class="math inline">\(sqrt\)</span>()
的运算即可。（注意，遍历“近”点时，必须保证纵坐标有序）</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0X7FFFF;</span><br><span class="line">int n;</span><br><span class="line">int flag = 0;</span><br><span class="line">struct pont&#123;</span><br><span class="line">    double first,second;</span><br><span class="line">&#125;point[N];</span><br><span class="line"></span><br><span class="line">bool cmp(pont a,pont b)&#123;</span><br><span class="line">    if(a.first==b.first) return a.second&lt;b.second;</span><br><span class="line">    else if(a.first==b.first &amp;&amp;a.second==b.second) flag=1;</span><br><span class="line">    return a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line">bool cmps(int a,int b)&#123;</span><br><span class="line">    return point[a].second&lt;point[b].second;</span><br><span class="line">&#125;</span><br><span class="line">double cal(pont a,pont b)&#123;</span><br><span class="line">    return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));</span><br><span class="line">&#125;</span><br><span class="line">int temp[N];</span><br><span class="line">double merge(int l,int r)&#123;</span><br><span class="line">    if(r-l==1)&#123;</span><br><span class="line">        return cal(point[l],point[r]);   </span><br><span class="line">    &#125;</span><br><span class="line">    else if(l==r) return N;</span><br><span class="line">    int mid = (l+r)/2;</span><br><span class="line">    double d1 = merge(l,mid);</span><br><span class="line">    double d2 = merge(mid + 1,r);</span><br><span class="line">    int k = 0;</span><br><span class="line">    double d3 = N;</span><br><span class="line">    for(int i = l; i &lt;= r;i ++)</span><br><span class="line">    if(fabs(point[mid].first-point[i].first) &lt; min(d1,d2))</span><br><span class="line">        temp[k++] = i;</span><br><span class="line">    sort(temp, temp + k, cmps);</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        for(int j=1+i;j&lt;k &amp;&amp; fabs(point[temp[j]].second-point[temp[i]].second) &lt; min(d1,d2);j++)&#123;</span><br><span class="line">            d3 = min(d3,cal(point[temp[j]],point[temp[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min(min(d1,d2),d3);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;point[i].first&gt;&gt;point[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(point+1,point+n+1,cmp);</span><br><span class="line">    printf(&quot;%.4lf&quot;,merge(1,n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="c.前缀和逆序对coci2015-20162-vudu">C.前缀和+逆序对[COCI2015-2016#2
VUDU]</h2>
<p><strong><em>Q：给定一个长度为 n 的序列以及一个数 p
，求出该序列的平均数大于 p 的连续子列的个数。</em></strong></p>
<p>看到平均数，先想到前缀和。下面对前缀和做一些数学推导。设序列为 <span
class="math inline">\(a_{n}\)</span> ，前缀和为 <span
class="math inline">\(s_{n}\)</span> ，假设某连续子列满足题意，不妨设
<span class="math inline">\(k&gt;j\)</span> ，则有</p>
<p><span class="math display">\[
{\frac{\sum_{i=j}^{k}a_{i}}{k-j}\geq p} \tag{C.1}
\]</span></p>
<p>即</p>
<p><span class="math display">\[
{\frac{s_{k}-s_{j}}{k-j}}\geq p  \Leftrightarrow s_{k}-kp\geq s_{j} -jp
\tag{C.2}\quad(j,k\in[0,n])
\]</span></p>
<p><span
class="math inline">\((2)\)</span>式右端极其对称，考虑构造新数列</p>
<p><span class="math display">\[
{b_{n}=\sum_{i=1}^{n}a_{i}-np\quad(n&gt;0)\\}\tag{C.3}
\]</span></p>
<p>特别地，令 <span class="math inline">\(b_{0}=0\)</span> ，使<span
class="math inline">\((C.2)\)</span>和 <span
class="math inline">\((C.3)\)</span> 完全等价。（这是因为 <span
class="math inline">\(j\)</span> 在 <span
class="math inline">\((C.3)\)</span> 中不能取到0，而在 <span
class="math inline">\((C.2)\)</span> 中可以取到 <span
class="math inline">\(0\)</span> ）</p>
<p>考察 <span class="math inline">\(b_{n}\)</span> 的递推式，易得</p>
<p><span class="math display">\[
{b_{n}=b_{n-1}+a_{n}-p\quad(n\geq0)\\}\tag{C.3&#39;}
\]</span></p>
<p>则题目变为求当 <span class="math inline">\(k&gt;j\)</span>时，<span
class="math inline">\(b_{j}\leq b_{k}\)</span> 的 <span
class="math inline">\((j,k)\)</span> 对数。</p>
<p>推完了，这不就求顺序对吗？两个办法：归并排序或树状数组。本人代码里用的是归并。（直接把板子弄过来的
<del>我是fw，归并改了半天不对</del>）</p>
<p>说一下树状数组的思路：简单来说就是大型哈希，先将数组初始化为0，当输入每个值时，先查询一遍前缀和加到答案上，再使树状数组的对应该值的下标的值++即可。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">const int N = 1000005;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n;</span><br><span class="line">long long a[N];</span><br><span class="line">long long s[N];</span><br><span class="line">long long s2[N];</span><br><span class="line">long long ans = 0;</span><br><span class="line">long long d[N];</span><br><span class="line">long long p;</span><br><span class="line">void msort(int L, int R)//归并求逆序对</span><br><span class="line">&#123;</span><br><span class="line">    if (L == R) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (L + R) / 2;</span><br><span class="line">    msort(L, mid); msort(mid + 1, R);</span><br><span class="line">    for (int k = L; k &lt;= R; k++)a[k] = s2[k];</span><br><span class="line">    int i = L, j = mid + 1;</span><br><span class="line">    for (int k = L; k &lt;= R; k++) &#123;</span><br><span class="line">        if ((i &lt;= mid) &amp;&amp; (a[i]&lt;a[j] || j&gt;R))s2[k] = a[i++];</span><br><span class="line">        else s2[k] = a[j++], ans += mid - i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    s2[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        s2[i] = s2[i-1] + a[i] - p;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s2 + 1, s2 + n + 1);//翻转后求逆序对</span><br><span class="line">    s2[n+1] = 0;</span><br><span class="line">    msort(1, n+1);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(比较有思维难度的题)</p>
<hr />
<h2
id="d.分类讨论实数二分icpc2020-shanghai-r-walker">D.分类讨论+实数二分[ICPC2020
Shanghai R Walker]</h2>
<p><strong><em>Q:给出一段区间[0,n],给定两个点的位置<span
class="math inline">\(\boldsymbol
{x_{A},x_{B}}\)</span>它们分别能以<span
class="math inline">\(\boldsymbol{v_{A},v_{B}}\)</span>的速率在区间内移动，速度的方向变化认为是瞬时的，A、B的移动会留下轨迹，求出这个区间被轨迹完全覆盖的最短时间。</em></strong></p>
<p>乍一看有点像物理题。这题的确有种高考板块模型的味道，即对A、B的运动状态详尽分类，搜索出每种状态的时间后取最小值。下面对状态进行分类：(不妨设
<span class="math inline">\(x_{A}&gt;x_{B}\)</span> )</p>
<p>A.二者相向而行，此时完全覆盖的时间为:</p>
<p><span class="math display">\[
min(\frac{x_{B}}{v_{B}},\frac{n-x_{A}}{v_{A}}) \tag{D.1}
\]</span></p>
<p>B.二者之一单独完全覆盖了区间，此种情况的最小时间为</p>
<p><span class="math display">\[
min(\frac{min(n-x_A,x_{A})+n}{v_{A}},\frac{min(n-x_B,x_{B})+n}{v_{B}})
\tag{D.2}
\]</span></p>
<p>C.二者各自负责自己的一边。设分界线为 <span
class="math inline">\(mid\)</span> ,则此种情况的最小值为</p>
<p><span class="math display">\[
max(\frac{min(x_{A}-mid,n-x_{A})+n-mid}{v_{A}},\frac{min(x_{B},mid-x_{B})+x_{B}}{v_{B}})
\tag{D.3}
\]</span></p>
<p>这种情况不太好直接算出来，因此对 <span
class="math inline">\((D.3)\)</span> 式的 <span
class="math inline">\(mid\)</span> 在 <span
class="math inline">\([x_{B},x_{A}]\)</span> 上进行二分搜索。</p>
<p>最后，上三式取最小值即可。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t; cin &gt;&gt; t;</span><br><span class="line">	while (t--) &#123;</span><br><span class="line">		double n, x1, v1, x2, v2; cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; v1 &gt;&gt; x2 &gt;&gt; v2;</span><br><span class="line">		if (x1 &lt; x2) &#123;</span><br><span class="line">			swap(x1, x2);</span><br><span class="line">			swap(v1, v2);</span><br><span class="line">		&#125;</span><br><span class="line">		double ans = 0;</span><br><span class="line">		ans = min(min((2 * n - x1), n + x1) / v1, min((n + x2), 2 * n - x2) / v2);</span><br><span class="line">		ans = min(ans, max(x1 / v1, (n - x2) / v2));</span><br><span class="line">		double l = x2;</span><br><span class="line">		double r = x1;</span><br><span class="line">		while (r - l &gt;= 1e-7) &#123;</span><br><span class="line">			double mid = (l + r) / 2;</span><br><span class="line">			double m = (min(n - x1, x1 - mid) + n - mid) / v1; double q = (min(mid - x2, x2) + mid) / v2;</span><br><span class="line">			ans = min(ans, max(m, q));</span><br><span class="line">			if (m &gt; q) l = mid;</span><br><span class="line">			else r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.10lf\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="e.函数stolz定理华师数分">E.函数stolz定理[华师数分]</h2>
<p><strong><em>Q：设函数<span class="math inline">\(\boldsymbol
f\)</span>定义在<span
class="math inline">\(\boldsymbol{(a,+\infty)}\)</span>上，<span
class="math inline">\(\boldsymbol f\)</span>在每一个有限区间<span
class="math inline">\(\boldsymbol
{(a,b)}\)</span>上有界，并满足</em></strong></p>
<p><span class="math display">\[
\lim_{x\rightarrow+\infty}{(f(x+1)-f(x))}=A.
\]</span></p>
<p><strong><em>证明</em></strong></p>
<p><span class="math display">\[
\lim_{x\rightarrow+\infty}\frac{f(x)}{x}=A. \tag{E}
\]</span></p>
<p>证明：由题</p>
<p><span class="math display">\[
\forall \varepsilon,\exists M&gt;0,\forall x&gt;M,\left| f(x+1)-f(x)-A
\right|&lt; \varepsilon \tag{E.1}
\]</span></p>
<p>令</p>
<p><span class="math display">\[
g(x)=\frac{f(x)}{x}
\]</span></p>
<p>设<span class="math inline">\(f(x)\)</span>的界为<span
class="math inline">\(k\)</span>，并注意到</p>
<p><span class="math display">\[
\left| \frac{f(x)}{x}-A \right|=\frac{1}{x}\left|f(x)-Ax\right|
\tag{E.2}
\]</span></p>
<p>对<span class="math inline">\((E.2)\)</span>式右端进行构造</p>
<p><span class="math display">\[
\frac{1}{x}\left|f(x)-Ax\right|=\frac{1}{x}\left|\sum_{i=x-[x-M]+1}^{x}(f(i)-f(i-1)-A)+f(x-[x-M])-A(x-[x-M])\right|
\tag{E.2&#39;}
\]</span></p>
<p>结合</p>
<p><span class="math display">\[
x-M-1&lt;[x-M]\le x-M\\ M\le x-[x-M]&lt;M+1
\]</span></p>
<p>以及<span class="math inline">\((E.2&#39;)\)</span>、<span
class="math inline">\((E.1)\)</span>和绝对值不等式易见</p>
<p><span class="math display">\[
\begin{aligned} |g(x)-A| &amp;\leq
\frac{1}{x}\{\sum_{i=x-[x-M]+1}^{x}|f(i)-f(i-1)-A|+|f(x-[x-M])|+|A(x-[x-M])|
\}\\  &amp;&lt; \frac{1}{x}([x-M]\varepsilon+|A|(M+1)+k))\\
&amp;=\frac{[x-M]\varepsilon}{x}+\frac{k+(M+1)|A|}{x}\tag{E.3}
\end{aligned}
\]</span></p>
<p>考察等式右端第二项，注意到分式上方皆为常数，即有<span
class="math inline">\(\lim_{x\rightarrow+\infty}\frac{k+(M+1)|A|}{x}=0.\)</span>从而存在正数<span
class="math inline">\(M\)</span>,当<span
class="math inline">\(x&gt;M\)</span>时，对于任给正数<span
class="math inline">\(\varepsilon\)</span> ，有 <span
class="math inline">\(\frac{k+(M+1)|A|}{x}&lt; \varepsilon\)</span>
.因此当<span class="math inline">\(x&gt;M\)</span>时，有</p>
<p><span class="math display">\[
|g(x)-A|&lt;\frac{[x-M]\varepsilon}{x}+\frac{k+(M+1)|A|}{x}&lt;2\varepsilon\tag{E.4}
\]</span></p>
<p>这就证明了<span class="math inline">\((E)\)</span>.<span
class="math inline">\(\ \ \ \square\)</span></p>
<p>评注：这题证明方法类似stolz定理的证明，即依照极限定义式进行放缩。但由于函数非离散，需要对末端进行一些处理才能达到目的。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title>有限群</title>
    <url>/2024/07/09/%E6%8A%BD%E4%BB%A3%EF%BC%9A%E7%BE%A4%E8%AE%BA/</url>
    <content><![CDATA[<h1>群论补足1：有限群</h1>
<h2 id="群的陪集和分拆">群的陪集和分拆</h2>
<blockquote>
<p>定义1：设群 $H&lt;G$，对任意 $a \in G$ ，称</p>
<p>$$<br>
aH={ax:x\in H} \tag1<br>
$$</p>
<p>为 $G$ 关于 $H$ 的左（右）陪集.</p>
</blockquote>
<p>可以证明陪集构成群的一个分拆.先引入如下引理</p>
<blockquote>
<p>引理1：设映射</p>
<p>$$<br>
f:H\to aH  \  x \to ax<br>
$$</p>
<p>该映射为满射.</p>
</blockquote>
<p><em>证明：只需证对任意 $x,y \in H$ 有 $x=y \iff f(x)=f(y)$.充分性显然.必要性根据群的消去律也是显然的.</em></p>
<p>同时可以有如下论断</p>
<blockquote>
<p>论断1：对于群 $H&lt;G$ ，不同元素 $a,b$ 生成的陪集 $aH,bH$ 要么相等，要么不交。</p>
</blockquote>
<p><em>证明：假设 $aH \cap bH \neq \empty$， $ah_1 = bh_2 \in aH \cap bH$，由对称性只需证 $aH \subset bH$. 任取 $ah \in aH$，就有 $ah = (bh_2h_1^{-1})h=b(h_2h_1^{-1}h) \in bH$（利用假设）.这就完成了证明.</em></p>
<p>因此，陪集构成了群的一个分拆.下面由陪集引入商集的概念</p>
<blockquote>
<p>定义2：设群 $H&lt;G$ ，将 $G$ 关于 $H$ 的所有左陪集构成的集合</p>
<p>$$<br>
S:={aH:a\in G} \tag2<br>
$$</p>
<p>称作 $G$ 关于 $H$ 的商集，记作</p>
<p>$$<br>
G/H<br>
$$</p>
<p>同时称这个商集的大小为 $H$ 在 $G$ 中的指数，记作</p>
<p>$$<br>
[G:H]=|G/H| \tag3<br>
$$</p>
</blockquote>
<p>综合上述引理及命题，我们就有</p>
<blockquote>
<p>定理1（拉格朗日定理）：对于群 $H&lt;G$，有</p>
<p>$$<br>
|G|=[G:H]|H| \tag4<br>
$$</p>
</blockquote>
<p><em>证明：$|G|=|\cup_{a \in I}aH|=\sum_{a \in I}|aH|=\sum_{a \in I}|H|=[G:H]|H|$，其中 $I$ 为陪集不交的元素集合，它的大小就是指数.</em></p>
<p>这就有了子群的阶整除群的阶的推论，这一点是显而易见的.</p>
<p>我们考察何时两个陪集会相等，有如下引理</p>
<blockquote>
<p>引理2：对于 $G&lt;H$，陪集 $aH=bH$ 的充要条件是 $b^{-1}a \in H$.</p>
</blockquote>
<p><em>证明：考虑等价转换，只需证陪集 $aH=H$ 的充要条件是 $a \in H$.</em></p>
<p><em>必要性：根据群的封闭性立得 $aH \subset H$.同理有 $a^{-1}H \subset H$.立得结论.</em></p>
<p><em>充分性： $a=ae \in aH$.</em></p>
<p>根据上面的定理，我们有关于子群的重要定理</p>
<blockquote>
<p>定理2：对于群 $K&lt;G&lt;H$ 有</p>
<p>$$<br>
[H:K]=[G:K][H:G] \tag5<br>
$$</p>
</blockquote>
<p><em>证明：根据 $(4)$，这是显然的.</em></p>
<p>我们考察两个群 $H,K$ 的元素互相乘积所构成的集合</p>
<p>$$<br>
HK={hk:h\in H,k\in K}<br>
$$</p>
<p>一般地，群的乘积不是一个群.关于群的乘积是否是群有如下命题</p>
<blockquote>
<p>命题2：群的乘积是群当且仅当 $HK=KH$.</p>
</blockquote>
<p><em>证明：</em></p>
<p><em>充分性：设 $h_1k_1h_2k_2=e$，显然有 $h_2k_2=k_1^{-1}h_1^{-1} \in KH$，根据对称性立得.</em></p>
<p><em>必要性：与群的定义一一对照立得.</em></p>
<p>我们考察乘积的大小，有如下定理</p>
<blockquote>
<p>定理3：对于群 $K,H&lt;G$，有</p>
<p>$$<br>
|HK|=\frac{|H||K|}{|H\cap K|} \tag6<br>
$$</p>
</blockquote>
<p><em>证明：微调至</em></p>
<p>$$<br>
\frac{|HK|}{|K|}=\frac{|H|}{|H\cap K|} \tag{6’}<br>
$$</p>
<p><em>等号右端可依照陪集分割 $H$ 构成一个指标集 $I$ ，使得其中元素陪集不交并为 $H$.</em></p>
<p>$$<br>
H=\bigsqcup_{h\in I}h(H \cap K)\tag7<br>
$$</p>
<p><em>等式左端同样可以写成类似形式：</em></p>
<p>$$<br>
HK=\bigsqcup_{h\in I’} hK\tag8<br>
$$</p>
<p><em>注意，此时不需要关心 $HK$ 是否构成一个群.我们考虑证明 $|I|=|I’|$.尝试构造映射</em></p>
<p>$$<br>
f:h(K)\to h(H \cap K)\tag9<br>
$$</p>
<p><em>只需证对任意 $xK,yK：x,y\in H$ 有 $xK=yK \iff f(xK)=f(yK)$.</em></p>
<p><em>设 $xK=yK$，根据引理2，我们有 $y^{-1}x \in K$，因此有 $y^{-1}x \in H \cap K$.再次根据引理2即可得证.</em></p>
<hr>
<h2 id="正规子群和商群">正规子群和商群</h2>
<p>本节的最终目标是为陪集赋予群的结构.</p>
<p>首先定义左（右）陪集的乘法</p>
<p>$$<br>
(aH)(bH)=(abH) \tag{10}<br>
$$</p>
<p>考察这个定义是否是良定义的，就需要有 $a’H=aH,b’H=bH$ 推出 $a’b’H=abH$ .一般而言这个条件是不成立的，我们需要额外添加条件以达成目的.下面给出正规子群</p>
<blockquote>
<p>定义3：若 $N&lt;G$，$\forall a\in G$</p>
<p>$$<br>
aN=Na \tag{11}<br>
$$</p>
<p>称 $N$ 是 $G$ 的正规子群，记作</p>
<p>$$<br>
N \lhd G<br>
$$</p>
</blockquote>
<p>下面我们会看到正规子群的性质是非常良好的.它为陪集的乘法赋予了良定义.</p>
<blockquote>
<p>论断2：对于 $G$ 的正规子群 $N$，形如 $(10)$ 的定义是良定义的.</p>
</blockquote>
<p><em>证明：这里直接将 $(10)$ 看作群的乘法，有 $aNbN=abNN=abN$，其中最后一步可以根据封闭性和单位元分别推出左包含和右包含.这就由 $G$ 的乘法的良定义推出了 $(10)$ 的良定义.</em></p>
<p>这样，我们就可以构造出陪集的群：商群</p>
<blockquote>
<p>定理4：设 $N \lhd G$，则 $G/N$ 在由 $(10)$ 定义的乘法下构成群 $(G/N,\times)$，我们称为商群.</p>
</blockquote>
<p><em>证明：我们一一验证</em></p>
<p><em>单位元：$N$ 是单位元，显然由 $\forall a \in G,(aN)(eN)=aN$.反向同理.</em></p>
<p><em>逆元：$\forall a\in G,(aN)(a^{-1}N)=(aa^{-1})N=N$</em></p>
<p><em>封闭性：根据陪集的分拆性质即得.</em></p>
<p><em>结合律：不难由 $G$ 的结合律推出.</em></p>
<p>为了更好地判别正规子群，我们给出如下引理</p>
<blockquote>
<p>引理3：以下论断等价</p>
<p>$$<br>
H \lhd G<br>
$$</p>
<p>$$<br>
\forall a\in G,aNa^{-1}\subset N \tag{12}<br>
$$</p>
<p>$$<br>
\forall a\in G,\forall n \in N,ana^{-1} \in N \tag{13}<br>
$$</p>
</blockquote>
<p><em>证明：$(12)$ 与 $(13)$ 等价在集合上是显然的，现在只证 $(12)$ 和 $(11)$ 等价.</em></p>
<p><em>充分性：根据定义立得 $aNa^{-1}=N \subset N$.</em></p>
<p><em>必要性：根据定义立得 $aN \sub Na^{-1}$，$(12)$ 中将 $a$ 替换为 $a^{-1}$ 立得 $a^{-1}N(a^{-1})^{-1}=a^{-1}Na\subset N$，那么结论就是显然的了.</em></p>
<p>一般而言， $(12),(13)$ 在实践中能更好地利用正规子群的性质.</p>
<p>利用上面的铺垫，我们有几个简单的论断</p>
<blockquote>
<p>论断3：任意个正规子群的交还是正规子群.</p>
</blockquote>
<p><em>利用 $(13)$ 就能简洁地证明，这里略去证明.</em></p>
<blockquote>
<p>论断4：对于群 $G$，有 ${e} \lhd G,G \lhd G$.</p>
</blockquote>
<blockquote>
<p>论断5：交换群的子群都是正规子群.</p>
</blockquote>
<p><em>这些论断的证明都是平凡的，略去.</em></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>代数</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>点集拓扑：拓扑空间</title>
    <url>/2024/07/10/page-4/</url>
    <content><![CDATA[<h1 id="拓扑空间">拓扑空间</h1>
<h2 id="r-上的通常拓扑">$ R $ 上的通常拓扑</h2>
<p>为了研究 $ R $ 上的通常拓扑，我们先研究开区间和闭区间.</p>
<p>我们已经熟知，开区间是 <span
class="math inline">\(U:=\{x:a&lt;x&lt;b\}\)</span> ，闭区间是 <span
class="math inline">\(V:=\{x:a\leq x \leq b\}\)</span>.其中 $a,b R $
，也可以取到无穷.下面给出一个与分析中邻域概念雷同的，且在拓扑中常用的定义</p>
<blockquote>
<p>定义1：若 <span class="math inline">\(x\in \mathbb R ,\epsilon &gt;
0\)</span>，则以 <span class="math inline">\(x\)</span> 为圆心，<span
class="math inline">\(\epsilon\)</span> 为半径的开球为</p>
<p><span class="math display">\[
B(x,\epsilon):=\{y\in \mathbb R :|y-x|&lt;\epsilon\} \tag1
\]</span></p>
</blockquote>
<p>开球与邻域是相同的.</p>
<p>接下来考察开区间的性质</p>
<blockquote>
<p>论断1： <span class="math inline">\(U\)</span>
为一个开区间和以下论述等价： <span class="math inline">\(\forall x \in
U,\exists\epsilon&gt;0,B(x,\epsilon)\subset U\)</span>.</p>
</blockquote>
<p><strong><em>证明：</em></strong></p>
<p><em>充分性：不失一般性，假设开区间 <span
class="math inline">\(U:=(a,b)\)</span> 两端都是实数，对于任给的 <span
class="math inline">\(x\)</span> 只需取 <span
class="math inline">\(\epsilon=\min(|a-x|,|b-x|)\)</span>
即可满足论述.</em></p>
<p><em>必要性：显然.</em></p>
<p><em>两端存在无穷的情况考虑无穷的极大性即可得证.</em></p>
<p>接下来，我们从开区间中抽象出开集的概念</p>
<blockquote>
<p>定义2：若 $UR $，则称 <span class="math inline">\(U\)</span> 是 $ R $
上的开集，当 <span class="math inline">\(U\)</span> 满足 <span
class="math inline">\(\forall x \in
U,\exists\epsilon&gt;0,B(x,\epsilon)\subset U\)</span> 时.</p>
</blockquote>
<p>注意，开区间是开集的真子集，例如不交开区间的并就不是开区间，但它是开集.</p>
<p>为了引出闭集的概念，我们先引入与分析中极限雷同的极限点概念</p>
<blockquote>
<p>定义3：若 $AR $，称 $xR $ 为 <span class="math inline">\(A\)</span>
的一个极限点，当存在数列 <span class="math inline">\(\{a_n\} \subset
A\)</span>，<span class="math inline">\(\lim_{\infty}a_n=x\)</span>.</p>
</blockquote>
<blockquote>
<p>引理1：若 $AR $，则 $xR $ 为 <span class="math inline">\(A\)</span>
的一个极限点当且仅当 <span class="math inline">\(\forall
\epsilon&gt;0,\exists a\in A,|a-x|&lt;\epsilon\)</span>.</p>
</blockquote>
<p>这是分析中已经熟知的.</p>
<p>下面，我们引出闭区间的重要性质</p>
<blockquote>
<p>论断2：闭区间包含所有的极限点.</p>
</blockquote>
<p><strong><em>证明：</em></strong></p>
<p><em>我们假设存在 <span class="math inline">\(x \notin U\)</span>
是闭区间 <span class="math inline">\(U := [a,b]\)</span>
的极限点。考虑对于右端点，存在数列 <span class="math inline">\(\{a_n\}
\subset U\)</span>，<span
class="math inline">\(\lim_{\infty}a_n=x\)</span>，但是我们只要取 <span
class="math inline">\(\epsilon\)</span> 为一个比 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(b\)</span> 的距离小的数，就必然有一个 <span
class="math inline">\(a_i \in [k,x]\)</span>，这里 <span
class="math inline">\(k&gt;b\)</span>，<span
class="math inline">\(\epsilon=x-k\)</span>.这就引出了矛盾.左端点的证明是类似的.</em></p>
<p>我们根据这条性质抽象出闭集的概念</p>
<blockquote>
<p>定义4：若 $VR $，我们称 <span class="math inline">\(V\)</span>
为闭集当 <span class="math inline">\(V\)</span> 包含它的所有极限点.</p>
</blockquote>
<p>类似地，闭区间是闭集的真子集.</p>
<p>下面我们证明本节的最重要的成果</p>
<blockquote>
<p>定理1：设 $UR $ 为闭集，则 $ R - U$ 为开集.反之亦然.</p>
</blockquote>
<p>在证明前，我们必须明确一个概念：集合不一定有开、闭的性质，也就是说非开不一定是闭集，非闭不一定是开集.左开右闭区间就是显而易见的例子.</p>
<p><strong><em>证明：</em></strong></p>
<p><em>我们先设 <span class="math inline">\(U\)</span> 为开集，需证
<span class="math inline">\(V= \mathbb R - U\)</span>
为闭集.用反证法，假设 <span class="math inline">\(V\)</span>
不是闭集，那么 <span class="math inline">\(V\)</span>
不包含它的所有极限点，设该极限点为 <span class="math inline">\(x\in
U\)</span>，考虑数列 <span class="math inline">\(\{a_n\}\in
V\)</span>的极限，根据开集的定义，存在一个以该点为圆心的开球完全被 <span
class="math inline">\(U\)</span>
包含，因此该开球的半径外的数列各值不能以比半径更小的距离 <span
class="math inline">\(\epsilon\)</span>
逼近该极限点，也就是说必须存在一个或以上的 <span
class="math inline">\(a_i\)</span> 在该开球中，这与假设矛盾.</em></p>
<p><em>另一方面，我们设 <span class="math inline">\(V\)</span>
为闭集，需证 <span class="math inline">\(U= \mathbb R - V\)</span>
为开集，用反证法，假设 <span class="math inline">\(U\)</span>
不是开集，则存在一个点 <span
class="math inline">\(x\)</span>，它的任意小的开球 <span
class="math inline">\(B(x,\epsilon)\)</span> 不完全被 <span
class="math inline">\(U\)</span> 包含.我们设 <span
class="math inline">\(y \in B(x,\epsilon) \cap
U\)</span>，那么我们构造一个数列 <span
class="math inline">\(\{a_n\}\subset V\)</span>，只要取 <span
class="math inline">\(\epsilon\)</span>
为足够小的值，在这里不失一般性取为 <span
class="math inline">\(\frac{1}{n}\)</span>，让每一项满足 <span
class="math inline">\(a_n\in B(y,1/n) \cap V\)</span>，这样 <span
class="math inline">\(a_n\)</span> 就能以任意大小逼近 <span
class="math inline">\(y\)</span>，那么 <span
class="math inline">\(y\)</span> 就是 <span
class="math inline">\(V\)</span> 的一个极限点，必然是 <span
class="math inline">\(V\)</span> 的元素，这与假设矛盾.</em></p>
<p>这条定理说明开集和闭集是互补的，开集的补集是闭集.</p>
<hr />
<p>现在我们来研究开集和闭集的性质.</p>
<blockquote>
<p>定理2（开集的性质）：</p>
<ol type="1">
<li>空集和 $ R $ 是开集.</li>
<li>任意开集的并是开集.</li>
<li>有限开集的交是开集.</li>
</ol>
</blockquote>
<p><strong><em>证明：</em></strong></p>
<p><em>性质1是显然的.</em></p>
<p><em>对于性质2，我们设并集为 <span
class="math inline">\(U_0\)</span>，考虑任意元素 <span
class="math inline">\(x\in U_0\)</span>，它至少属于一个开集 <span
class="math inline">\(U\)</span>，即有对任意开球 <span
class="math inline">\(B(x,\epsilon)\)</span>，都有 <span
class="math inline">\(B(x,\epsilon)\in U \subset U_0\)</span>.</em></p>
<p><em>对于性质3，设大小为 <span class="math inline">\(n\)</span>
的开集族 <span class="math inline">\({U_i}\)</span> 的交集为 <span
class="math inline">\(U_0\)</span>，对任意 <span
class="math inline">\(x\in U_0\)</span>，取 <span
class="math inline">\(\epsilon = \min_{i \in
I}(\epsilon_i:B(x,\epsilon_i) \subset U_i)\)</span>，就有 <span
class="math inline">\(\forall i \in [1,n],B(x,\epsilon)\subset
B(x,\epsilon_i)\subset U_i\)</span>，这就完成了证明.</em></p>
<p>注意性质3必须要是有限个开集的交.因为确界原理：无限个数的最小值无法确定.</p>
<p>例如：区间套</p>
<p><span class="math display">\[
U_i=(\frac1i,\frac{1}{i+1})
\]</span></p>
<p>根据区间套原理，这个开集族交集是 <span
class="math inline">\(\{0\}\)</span>，显然不是开集.</p>
<p>根据对偶性，不难得出以下闭集的性质</p>
<blockquote>
<p>定理3：</p>
<ol type="1">
<li>空集和 $ R $ 是闭集.</li>
<li>有限闭集的并是闭集.</li>
<li>任意闭集的交是开集.</li>
</ol>
</blockquote>
<p><strong><em>证明：</em></strong></p>
<p><em>性质1是显然的.</em></p>
<p><em>对于性质2，考虑定理2的性质3，有限闭集的并就是它们补集的交的补集.</em></p>
<p><em>性质3同理.</em></p>
<p>为了熟悉拓扑的语言，我们引入闭包</p>
<blockquote>
<p>定义5： <span class="math inline">\(A\)</span> 的闭包是一个包含 <span
class="math inline">\(A\)</span> 的所有极限点（闭包点）的集合，记作
<span class="math inline">\(\overline A = cl(A)\)</span>.</p>
</blockquote>
<p>很自然地我们想替换闭集的语言</p>
<blockquote>
<p>引理2：<span class="math inline">\(V\)</span> 是 $ R $
的闭子集当且仅当 <span class="math inline">\(V= \overline
V\)</span>.</p>
</blockquote>
<p>不证.</p>
<p>接下来我们就可以刻画 <span class="math inline">\(R\)</span>
上的通常拓扑形态</p>
<blockquote>
<p>定义6：设 <span class="math inline">\(A \subset \mathbb
R\)</span>，我们有</p>
<ol type="1">
<li><span class="math inline">\(A\)</span> 的内部</li>
</ol>
<p><span class="math display">\[
\operatorname{Int}(A)  = \{x \in  \mathbb R :\exists \epsilon
&gt;0,B(x,\epsilon) \subset A \}=\{x \in  \mathbb R :\exists \epsilon
&gt;0,B(x,\epsilon) \cap  \mathbb R -A =\empty \} \tag2
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(A\)</span> 的外部</li>
</ol>
<p><span class="math display">\[
\operatorname{Ext}(A)=\{x \in  \mathbb R :\exists \epsilon
&gt;0,B(x,\epsilon) \subset  \mathbb R -A \}=\{x \in  \mathbb R :\exists
\epsilon &gt;0,B(x,\epsilon) \cap  A =\empty \} \tag3
\]</span></p>
<ol start="3" type="1">
<li><span class="math inline">\(A\)</span> 的边界</li>
</ol>
<p><span class="math display">\[
\partial A = \mathbb R-\operatorname{Int}(A)-\operatorname{Ext}(A) \tag4
\]</span></p>
</blockquote>
<p>这样我们就能刻画一个拓扑的内、外、边界了.下一节将讨论边界的性质.</p>
]]></content>
      <categories>
        <category>点集拓扑</category>
      </categories>
      <tags>
        <tag>拓扑</tag>
      </tags>
  </entry>
</search>
