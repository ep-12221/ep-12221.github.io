<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>奇奇怪怪的线代题(1)</title>
    <url>/2023/12/01/page-2/</url>
    <content><![CDATA[<h1 id="一些奇奇怪怪的线代题">一些奇奇怪怪的线代题</h1>
<h2 id="a.行列式">A.行列式</h2>
<p><em>1.计算<span class="math inline">\(n\)</span>阶行列式</em></p>
$$ D_n = |
<span class="math display">\[\begin{array}{cccc}
2\cos x &amp;1   &amp; 0 &amp; \dots &amp;0&amp;0\\
1 &amp;2\cos x &amp; 1 &amp; \dots &amp;0&amp;0\\
0 &amp;1 &amp;2\cos x &amp;  \dots &amp;0&amp;0\\

\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp; 0 &amp; \dots &amp;2\cos x&amp;1\\
0 &amp;0 &amp; 0 &amp; \dots &amp;1&amp;2 \cos x\\

\end{array}\]</span>
<p>|. $$</p>
<p>将其按第一行展开：</p>
$$ D_n = |
<span class="math display">\[\begin{array}{cccc}
2\cos x &amp;1   &amp; 0 &amp; \dots &amp;0&amp;0\\
1 &amp;2\cos x &amp; 1 &amp; \dots &amp;0&amp;0\\
0 &amp;1 &amp;2\cos x &amp;  \dots &amp;0&amp;0\\

\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp; 0 &amp; \dots &amp;2\cos x&amp;1\\
0 &amp;0 &amp; 0 &amp; \dots &amp;1&amp;2 \cos x\\

\end{array}\]</span>
| \=2x |
<span class="math display">\[\begin{array}{cccc}
2\cos x &amp;1    &amp; \dots &amp;0&amp;0\\
1 &amp;2\cos x  &amp; \dots &amp;0&amp;0\\
\vdots  &amp; \vdots &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp; \dots &amp;2\cos x&amp;1\\
0 &amp;0  &amp; \dots &amp;1&amp;2 \cos x\\
\end{array}\]</span>
| - |
<span class="math display">\[\begin{array}{cccc}
1 &amp;1   &amp; \dots &amp;0&amp;0\\
0 &amp;2\cos x  &amp; \dots &amp;0&amp;0\\
\vdots &amp; \vdots  &amp; &amp;\vdots &amp; \vdots \\
0 &amp;0 &amp;  \dots &amp;2\cos x&amp;1\\
0 &amp;0 &amp;  \dots &amp;1&amp;2 \cos x\\
\end{array}\]</span>
<p>|\= 2D_{n-1} - D_{n-2} $$</p>
<p>因此<span
class="math inline">\(D_n\)</span>为二阶线性递推数列，求特征根得</p>
<p><span class="math display">\[
\lambda_1=\cos x + i\sin x,\lambda_2=\cos x-i\sin x
\]</span></p>
<p>结合<span class="math inline">\(D_1=2\cos x\)</span>以及<span
class="math inline">\(D_2 = 4\cos^2 x - 1\)</span>得</p>
<p><span class="math display">\[
D_n = \cos nx + \cot x\sin nx.
\]</span></p>
<hr />
<p><em>2.计算n阶行列式</em></p>
$$ D_n = |
<span class="math display">\[\begin{array}{cccc}
1 &amp;1 &amp; \dots &amp;1\\
x &amp;x &amp;\dots&amp;x\\
x^2 &amp;x^2&amp;\dots &amp;x^2\\

\vdots &amp; \vdots &amp; &amp; \vdots \\
x^{n-2} &amp;x^{n-2}&amp;\dots &amp;x^{n-2}\\
x^n &amp;x^n &amp; \dots &amp;x^n\\

\end{array}\]</span>
<p>|. $$</p>
<p>考虑<span class="math inline">\(n+1\)</span>阶范德蒙德行列式</p>
$$ |
<span class="math display">\[\begin{array}{cccc}
1 &amp;1 &amp; \dots &amp;1&amp;1\\
x &amp;x &amp;\dots&amp;x&amp;y\\
x^2 &amp;x^2&amp;\dots &amp;x^2&amp;y^2\\

\vdots &amp; \vdots &amp; &amp; \vdots &amp;\vdots\\
x^{n-2} &amp;x^{n-2}&amp;\dots &amp;x^{n-2}&amp;y^{n-2}\\
x^{n-1} &amp;x^{n-1}&amp;\dots &amp;x^{n-1}&amp;y^{n-1}\\

x^n &amp;x^n &amp; \dots &amp;x^n&amp;y^n\\

\end{array}\]</span>
<p>|=<em>{k=1}^n(y-x_k)</em>{1j&lt;in}(x_i-x_j) $$</p>
<p>按第<span class="math inline">\(n+1\)</span>列展开：</p>
<p><span class="math display">\[
D_{n+1} = A_{1,n+1} + yA_{2,n+1}+\dots +y^{n-1}A_{n,n+1}+y^nA_{n+1,n+1}
\]</span></p>
<p>并注意到</p>
<p><span class="math display">\[
A_{n,n+1} = -D_n
\]</span></p>
<p>以及</p>
<p><span class="math display">\[
\prod \limits_{k=1}^n(y-x_k) = y^n-y^{n-1}\sum_{k=1}^{n}x_k+\dots
+(-1)^n\prod_{k=1}^{n}x_k
\]</span></p>
<p>从而</p>
<p><span class="math display">\[
D_n = \sum_{k=1}^{n}x_k\prod_{1\le j&lt;i\le n}(x_i-x_j).
\]</span></p>
<hr />
<h2 id="b.证明题">B.证明题</h2>
<p><em>设<span class="math inline">\(\{\alpha _i\}\)</span>为<span
class="math inline">\(n-1\)</span>个线性无关的<span
class="math inline">\(n\)</span>维向量组，<span
class="math inline">\(\xi
_1,\xi_2\)</span>为与该向量组向量均正交的两个<span
class="math inline">\(n\)</span>维列向量，证明：<span
class="math inline">\(\xi _1,\xi_2\)</span>线性相关。</em></p>
<p>证明：将 $_1 $ 添入向量组中，考虑到正交即线性无关，包含 <span
class="math inline">\(\xi _1\)</span> 的向量组即为空间的一组基，并设
<span class="math inline">\(\xi_1\)</span> 在该组基下的坐标表示为<span
class="math inline">\((k_1,k_2,\dots k_n)\)</span>即有</p>
<p><span class="math display">\[
\xi_1 ^T\xi _2 =(\sum_{i=1}^{n-1}k_i\alpha_i^T+k_n\xi_2^T)\xi
_2=k_n\xi_2^T\xi_2
\]</span></p>
<p>以及</p>
<p><span class="math display">\[
\xi_1 ^T\xi _1 =(\sum_{i=1}^{n-1}k_i\alpha_i^T+k_n\xi_2^T)\xi
_1=k_n\xi_2^T\xi_1
\]</span></p>
<p>从而有</p>
<p><span class="math display">\[
\frac{\xi_1 ^T\xi _2 }{\xi_2^T\xi_2}=\frac{\xi _1^T \xi_1}{\xi_2^T\xi_1}
\]</span></p>
<p>写成内积的形式：</p>
<p><span class="math display">\[
||(\xi_1, \xi_2)||^2 =(||\xi_2||^2)(||\xi _1||^2)
\]</span></p>
<p>此即欧氏空间的柯西不等式等号成立的情况，当且仅当<span
class="math inline">\(\xi_1,\xi_2\)</span>线性相关。<span
class="math inline">\(\square\)</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>代数</tag>
        <tag>行列式</tag>
        <tag>柯西不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>CODEFORCES ROUND 913 DIV.3</title>
    <url>/2023/12/06/div3/</url>
    <content><![CDATA[<h1 id="codeforces-round-913-div.3">CODEFORCES ROUND 913 DIV.3</h1>
<h2 id="第一次的cf-rated赛">第一次的cf rated赛</h2>
<p>打得依托构思</p>
<hr />
<h2 id="a.rook">A.ROOK</h2>
<p><strong><em>给出国际象棋中的车在棋盘中的棋谱位置，求出其能移动到的所有地方。</em></strong></p>
<p>水模拟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int t;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">            if (i == s[1] - &#x27;0&#x27;)</span><br><span class="line">                continue;</span><br><span class="line">            cout &lt;&lt; s[0] &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            if (i == s[0] - &#x27;a&#x27;)</span><br><span class="line">                continue;</span><br><span class="line">            cout &lt;&lt; char(i + &#x27;a&#x27;) &lt;&lt; s[1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.yetnotherrokenkeoard">B.YetnotherrokenKeoard</h2>
<p><strong><em>给出几串输入字符串，当按下“b”键时，删除键入的字符串中最后一个（最右边）小写字母。如果键入的字符串中没有小写字母，则完全忽略按键。</em></strong></p>
<p><strong><em>"B"同理。</em></strong></p>
<p>用两个栈分别维护大小写字母即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int t;</span><br><span class="line">int m[1000010];</span><br><span class="line">stack&lt;int&gt; upper;</span><br><span class="line">stack&lt;int&gt; lower;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (s[i] != &#x27;b&#x27; &amp;&amp; s[i] != &#x27;B&#x27;) &#123;</span><br><span class="line">                if (isupper(s[i]))</span><br><span class="line">                    upper.push(i);</span><br><span class="line">                else if (islower(s[i]))</span><br><span class="line">                    lower.push(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!lower.empty() &amp;&amp; s[i] == &#x27;b&#x27;)</span><br><span class="line">                    lower.pop();</span><br><span class="line">                else if (!upper.empty() &amp;&amp; s[i] == &#x27;B&#x27;)</span><br><span class="line">                    upper.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!upper.empty()) &#123;</span><br><span class="line">            m[upper.top()] = 1;</span><br><span class="line">            upper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while (!lower.empty()) &#123;</span><br><span class="line">            m[lower.top()] = 1;</span><br><span class="line">            lower.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (m[i])</span><br><span class="line">                cout &lt;&lt; s[i], m[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="c.removal-of-unattractive-pairs">C.Removal of Unattractive
Pairs</h2>
<p><strong><em>给出几串字符串，若某相邻的两个字符不同，则可以将它们从字符串中移除，求出每个字符串能达到的最小长度。</em></strong></p>
<p><strong>引理：若两个字符串除了排列顺序以外其余因素完全相同，则该两个字符串的最小长度及其对应的排列相同。</strong></p>
<p>证明：考虑归纳证明，设 $a_i $为长度为 $i $的字符串 $a
$所能达到的最小长度对应的字符串。</p>
<p>当 $n=1,2 $时显然成立；</p>
<p>假设当 $n=k
$时成立，最平凡的情况即为每个字符相等，这种情况的正确性是显然的。假若非平凡，则有
$a_{k}=b_{k} $，其中 $b $为除 $a $以外的任意一种排列。当 $n=k+1 $时，对
$a,b $增添的字母必然一致，设为 $s $。考虑到 $a $的任意性，不妨让 $a
$在其左端添上 $s $成为 $sa
$，（这是因为若需要在中间插入，则可以由另外一串字符串来证明），那么对 $b
$可以进行任意变换，使 $sa = b's $，则根据 $nk $的假设，引理得证。 $$</p>
<p>那么我们可以将每个字符串重排成一种形状：左端放满其包含最多的字符串，其余放在右端
$ LLLLLLx_1x_2$</p>
<p>那么我们可以从中间开始消消乐，关于最小长度的结论就是显然的了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int m[30];</span><br><span class="line">int t;</span><br><span class="line">deque&lt;char&gt; p;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            m[s[i] - &#x27;a&#x27;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for (int i = 0; i &lt;= 26; i++) &#123;</span><br><span class="line">            tmp = max(tmp, m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (n % 2) &#123;</span><br><span class="line">            if ((n + 1) / 2  &lt;= tmp)</span><br><span class="line">                cout &lt;&lt; 2 * (tmp - (n + 1) / 2) + 1 &lt;&lt; endl;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((n) / 2  &lt;= tmp)</span><br><span class="line">                cout &lt;&lt; 2 *(tmp - n / 2) &lt;&lt; endl;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(m, 0, sizeof(m));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="d.jumping-through-segments">D.Jumping Through Segments</h2>
<p><strong><em>按顺序给出一些区间，最小化每步都能跳到该步对应的区间中的步长的最大值，初始在零点。</em></strong></p>
<p>容易知道是二分。</p>
<p>考虑chk的写法：<strong>每次跳至的位置设置成一个区间</strong>，区间下限、上限均为相对于题给区间合法的上下限，若区间不合法(l&gt;k)即为false，否则为true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma GCC optimize(2)</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">int n,t;</span><br><span class="line">struct p&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">&#125;a[1000001];</span><br><span class="line"></span><br><span class="line">int chk(int x)&#123;</span><br><span class="line">    int l = 0,r = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        l -= x,r += x;</span><br><span class="line">        l = max(l,a[i].l);</span><br><span class="line">        r = min(r,a[i].r);</span><br><span class="line">        if(l &gt; r) return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">        int l = 0,r = 1e9 + 10;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">            if(chk(mid)) ans = mid,r = mid;</span><br><span class="line">            else l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="e.good-triples">E.Good Triples</h2>
<p><strong><em>给定若干个数 $n $，求满足 $a+b+c=n $以及 $a,b,c
$的各位和与 $n $的各位和相等的三元有序数对 $(a,b,c)
$的个数。</em></strong></p>
<p><strong>命题：满足题述条件的数对个数</strong> $ S=_{i=1}^{O(n)}()
$</p>
<p><strong>其中 $n_i $为 $n $的十进制数对应位数 $i $的数值， $O(n) $为
$n $的最高位数。</strong></p>
<p>证明：注意到所有对于 $a,b,c,n
$的各位和相等的等式均能拆成唯一一种按位排列的情形（位数不足时用0补足），即：
$ a_1 +b_1+c_1=n_1,a_2+b_2+c_2=n_2,$</p>
<p>并且上式每位数按对应位数进位后完全契合 $a+b+c=n
$，根据乘法原理，总情况数即为每位数对应分解情况数的乘积，即问题化归到求10以内的分解情况。</p>
<p>对0而言，只有唯一一种分解情况；当为 $1
$时，有三种分解情况；为2时，有六种分解情况；猜想对于 $n $，分解情况为
$_{i=1}^{1+n}i $，下面归纳证明。 $n=0 $情形已枚举；</p>
<p>假设 $n=k,n&lt;9 $时成立，则当 $ n=k+1 $时，考虑对 $n=k
$的每种情况的数对第一位加一，皆符合分解式，只缺少第一位为0的情况，即
$(0,x,y),x+y=k $，这样的数对共有0到 $k $共 $k+1
$种，这就完成了归纳证明，同时完成了命题的证明。 $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">// int a[100001];</span><br><span class="line">int t, n;</span><br><span class="line">signed main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 1e7; i &gt;= 1; i /= 10) &#123;</span><br><span class="line">            ans *= ((n / i + 1) * (n / i + 2)) / 2;</span><br><span class="line">            n %= i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="f.shift-and-reverse">F.Shift and Reverse</h2>
<p><strong><em>给出一些数列，考虑只用头尾翻转和用头接尾两种方法能不能将该数列按照非降序排序，并求出排序步数最小值。</em></strong></p>
<p><strong>引理：将该序列看成一个尾连头的环，即 $(a_1,a_2,,a_n,a_1,)
$，若其中不重复的向右相邻的顺序与逆序的数量的最小值比1大，则无法做出排序。</strong></p>
<p>证明：若能注意到顺序逆序总和为 $n
$以及逆向构造：1.翻转让顺逆序数互换；2.尾接头最多构造出1个顺/逆序，那么结论是显然的。
$$</p>
<p>那么若能排序，则可以考虑逆向构造，在已排序环的第一第二节里截出满足与目标序列相同或只差一次翻转的序列后将需移动位置和反转次数相加，取极小即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t, n;</span><br><span class="line">int a[100001];</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        int p = 0, q = -1, ans = 0x7fffff;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (a[i] &gt; a[(i + 1) % n])&#123;</span><br><span class="line">                p++;q = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout&lt;&lt;p&lt;&lt;&quot; &quot;;</span><br><span class="line">        if (p == 0)</span><br><span class="line">            ans = 0;</span><br><span class="line">        else if (p == 1) &#123;</span><br><span class="line">            int tmp = min(q + 2, n - q);</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        p = 0,q = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (a[i] &lt; a[(i + 1) % n])&#123;</span><br><span class="line">                p++;q = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout&lt;&lt;p&lt;&lt;&quot; &quot;;</span><br><span class="line">        if (p == 0)</span><br><span class="line">            ans = 0;</span><br><span class="line">        else if (p == 1) &#123;</span><br><span class="line">            int tmp = min(q + 1, n - q + 1);</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ans == 0x7fffff)</span><br><span class="line">            ans = -1;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="g.lights">G.Lights</h2>
<p><strong><em>给出一组灯的开关状态，以及一组数 $a_1,a_2,a_n $表示开关
$i $能改变 $i,a_i
$两盏灯的状态，考虑能不能将灯全部关上，若能关上求出关上全部灯的最少步数。</em></strong></p>
<p>注意到这里共有 $n $个开关， $n
$个有向关系，可以建成一张有向图，且该图有且仅有一个环，其余的节点都为从环上衍生出去的链，那么可以考虑模拟将每个链上的灯的开关情况规整到环上，现在只需讨论环上的情况。很容易知道环上开灯的为奇数则无法关上，为偶数可以关上。</p>
<p>现在考虑怎么求最小值。其实只用求环上两个相邻开灯节点的距离最大值，然后避开这段反着扫一遍就是答案。</p>
<p>代码：改代码中</p>
]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>数论笔记</title>
    <url>/2024/01/28/page-3/</url>
    <content><![CDATA[<h1 id="数论笔记不断更新">数论笔记（不断更新）</h1>
<h2 id="a">A</h2>
<p><strong><em>有一组给定的序列，构造一个数，使这个序列关于这个数的模有且仅有两个数。</em></strong></p>
<p><strong>结论：所求答案为：</strong></p>
<p><span class="math display">\[
ans = 2(a_2-a_1,a_3-a_2,\dots,a_n-a_{n-1})
\]</span></p>
<p><strong>证明：</strong></p>
<p>首先可以证明</p>
<p><span class="math display">\[
a_i \equiv a_j \pmod {(a_2-a_1,a_3-a_2,\dots,a_n-a_{n-1})}(\forall{i,j
\in[1,n]})
\]</span></p>
<p>设模值为 <span class="math inline">\(G=
(a_2-a_1,a_3-a_2,\dots,a_n-a_{n-1})\)</span>，并设</p>
<p><span class="math display">\[
a_i=p_iG+x \tag{A.1}
\]</span></p>
<p>考察 <span class="math inline">\(p_i\)</span> 的奇偶性，以下 <span
class="math inline">\(t\)</span> 为整数。若为奇数，便有</p>
<p><span class="math display">\[
a_i=(2t+1)G+x \rightarrow a_i \equiv G+x \pmod{2G}
\]</span></p>
<p>若为偶数，则有</p>
<p><span class="math display">\[
a_i=(2t)G+x \rightarrow a_i \equiv x \pmod{2G}
\]</span></p>
<p>下面证明任意序列 <span class="math inline">\(p_i\)</span>
必然不关于2同余。这是因为若关于2同余，那么对任意 <span
class="math inline">\(i,j \in [1,n]\)</span>，</p>
<p><span class="math display">\[
(p_i-p_j)|2
\]</span></p>
<p>利用<span class="math inline">\((1)\)</span>立得</p>
<p><span class="math display">\[
a_i - a_j=(p_i-p_j)G \rightarrow a_i - a_j\equiv 0 \pmod{2G}
\]</span></p>
<p>与所设 <span class="math inline">\(G\)</span> 矛盾，命题得证。<span
class="math inline">\(\square\)</span></p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>做题笔记2023/11/16</title>
    <url>/2023/11/17/page-1/</url>
    <content><![CDATA[<p>若不说明，下标中的数均为整数。</p>
<h1 id="线性dp">1.线性DP</h1>
<h2 id="a.poi2013-baj-bytecomputer">A.[POI2013] BAJ-Bytecomputer</h2>
<p><strong><em>给定一个长度为 <span class="math inline">\(n\)</span>
的只包含 <span class="math inline">\(-1,0,1\)</span> 的数列 <span
class="math inline">\(a\)</span>，每次操作可以使 <span
class="math inline">\(a_i\gets
a_i+a_{i-1}\)</span>，求最少操作次数使得序列单调不降。如果不可能通过该操作使得序列单调不降，请输出
<code>BRAK</code>。</em></strong></p>
<p><strong><em>数据范围：<span class="math inline">\(1\le n\le
10^6\)</span>。</em></strong></p>
<p><strong>引理</strong>：如果要求操作最少，则该数列中只有<span
class="math inline">\(1,0,-1\)</span>三种值。</p>
<p>证明：若不然，设最终序列中的第一个比<span
class="math inline">\(-1\)</span>小的数为<span
class="math inline">\(a_{i}\)</span>，注意到<span
class="math inline">\(i&gt;1\)</span>，且<span
class="math inline">\(a_{i-1}\leq
-1\)</span>，这与单调不降矛盾，比1大的情形可以类似地证明。<span
class="math inline">\(\square\)</span></p>
<p>从而该数组每个操作后的数可以唯一确定，并且若操作的数前的数列单调不降，要使包括该数在内的数列单调不降，只需要操作该数。该问题具有最优子结构且易于定态，可以考虑DP处理。设<span
class="math inline">\(dp[i][j]\)</span>为在前<span
class="math inline">\(i\)</span>个数为单调不降且第<span
class="math inline">\(i\)</span>个数为<span
class="math inline">\(j\)</span>的最小操作数，容易知道<span
class="math inline">\(dp[1][a[1]] =
0\)</span>，并将其余状态初始化为<span
class="math inline">\(+\infty\)</span>，对<span
class="math inline">\(a[i]\)</span>、<span
class="math inline">\(j\)</span>分情况讨论：</p>
<hr />
<p>若<span class="math inline">\(a[i]=-1\)</span></p>
<p>1.<span class="math inline">\(j=-1\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>只能是<span
class="math inline">\(-1\)</span>，即</p>
<p><span class="math display">\[
dp[i][-1]=dp[i-1][-1] \tag{1}
\]</span></p>
<p>2.<span
class="math inline">\(j=0\)</span>，容易知道无论前一个数是多少都无法转移。</p>
<p>3.<span class="math inline">\(j=1\)</span>,则<span
class="math inline">\(a_{i-1}\)</span>可以任取，但不能从<span
class="math inline">\(0,-1\)</span>转移得到，即</p>
<p><span class="math display">\[
dp[i][1] = dp[i-1][1]+2 \tag{2}
\]</span></p>
<hr />
<p>若<span class="math inline">\(a[i]=0\)</span></p>
<p>1.<span class="math inline">\(j=-1\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>只能是<span
class="math inline">\(-1\)</span>，即</p>
<p><span class="math display">\[
dp[i][-1]=dp[i-1][-1] + 1 \tag{3}
\]</span></p>
<p>2.<span class="math inline">\(j=0\)</span>，则前一个数可以是<span
class="math inline">\(-1,0\)</span>，即</p>
<p><span class="math display">\[
dp[i][0]=\min(dp[i-1][-1],dp[i-1][0]) \tag{4}
\]</span></p>
<p>3.<span class="math inline">\(j=1\)</span>,则<span
class="math inline">\(a_{i-1}\)</span>可以任取，但不能从<span
class="math inline">\(0,-1\)</span>转移得到，即</p>
<p><span class="math display">\[
dp[i][1] = dp[i-1][1]+1 \tag{5}
\]</span></p>
<hr />
<p>若<span class="math inline">\(a[i]=1\)</span></p>
<p>1.<span class="math inline">\(j=-1\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>不能取<span
class="math inline">\(1，0\)</span>，即</p>
<p><span class="math display">\[
dp[i][-1]=dp[i-1][-1]+2\tag{6}
\]</span></p>
<p>2.<span class="math inline">\(j=0\)</span>，则<span
class="math inline">\(a_{i-1}\)</span>不能取<span
class="math inline">\(1，0\)</span>，即</p>
<p><span class="math display">\[
dp[i][0]=dp[i-1][-1]+1\tag{7}
\]</span></p>
<p>3.<span class="math inline">\(j=1\)</span>,则<span
class="math inline">\(a_{i-1}\)</span>可以任取，即</p>
<p><span class="math display">\[
dp[i][1]=\min(dp[i-1][-1],dp[i-1][0],dp[i-1][1]) \tag{8}
\]</span></p>
<p>综合上述八式，优化下标，查询<span
class="math inline">\(\max(dp[n][0],dp[n][1],dp[n][-1])\)</span>，若为<span
class="math inline">\(+\infty\)</span>则无解，否则输出答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n;</span><br><span class="line">int a1[N];</span><br><span class="line">int dp[N][7];</span><br><span class="line">//2=-1,3=0,4=1;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a1[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= 1000500; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 7; j++)</span><br><span class="line">            dp[i][j] = N;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a1[i]; &#125;</span><br><span class="line">    int p = a1[1];</span><br><span class="line">    dp[1][p + 3] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][2] = dp[i - 1][2] + a1[i] + 1;</span><br><span class="line">        if (a1[i] == 0)dp[i][3] = min(dp[i - 1][2], dp[i - 1][3]);</span><br><span class="line">        else if (a1[i] == 1) dp[i][3] = dp[i - 1][2] + 1;</span><br><span class="line">        if (a1[i] == 1) dp[i][4] = min(min(dp[i - 1][2], dp[i - 1][3]), dp[i - 1][4]);</span><br><span class="line">        else dp[i][4] = dp[i - 1][4] - a1[i] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[n][2] &gt;= N &amp;&amp; dp[n][3] &gt;= N &amp;&amp; dp[n][4] &gt;= N) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;BRAK&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; min(min(dp[n][3], dp[n][2]), dp[n][4]);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.scoi2009-粉刷匠">B.[SCOI2009] 粉刷匠</h2>
<p><strong><em>windy 有 <span class="math inline">\(N\)</span>
条木板需要被粉刷。 每条木板被分为 <span class="math inline">\(M\)</span>
个格子。 每个格子要被刷成红色或蓝色。</em></strong></p>
<p><strong><em>windy
每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。
每个格子最多只能被粉刷一次。</em></strong></p>
<p><strong><em>如果 windy 只能粉刷 <span
class="math inline">\(T\)</span>
次，他最多能正确粉刷多少格子？</em></strong></p>
<p><strong><em>一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。</em></strong></p>
<p><strong><em>数据范围：<span class="math inline">\(1 \le N,M \le 50,0
\le T \le 2500\)</span></em></strong></p>
<p>将每条木板看作一组物品，则题目变为分组背包。那么问题落到了如何求这一组物品的每个次数的最多正确粉刷数上。</p>
<p>考虑如何定态，首先要有涂了<span
class="math inline">\(k\)</span>次作为状态，此外还要有前<span
class="math inline">\(j\)</span>个为最小作为递推依据，用<span
class="math inline">\(i\)</span>来表示是第几条木板。在每次状态转移时，需要遍历前面所有<span
class="math inline">\(k\)</span>到<span
class="math inline">\(j\)</span>的少涂一次的状态（这是因为不可能有比<span
class="math inline">\(k\)</span>小的区间涂了k次），并加上从<span
class="math inline">\(q\)</span>到<span
class="math inline">\(j\)</span>的最多的颜色即可，即：</p>
<p><span class="math display">\[
dp1[i][j][k]=\max(dp1[i][q][k - 1] + \max(a[i][j] - a[i][q], j - q -
(a[i][j] - a[i][q])))(q\in(k,j)) \tag{1}
\]</span></p>
<p>其中<span
class="math inline">\(a[i][j]\)</span>为用0-1前缀和来存每个区间内的颜色个数。初态为<span
class="math inline">\(dp1[i][j][k]=0\)</span>。</p>
<p><strong>注意：应先循环涂的次数再循环涂了第几个，这与区间DP先循环区间长度再循环从第几个开始涂相似，都是用次数作为每一维的递推依据，再在这一维做第几个的递推。</strong></p>
<p><strong>从而<span
class="math inline">\(dp[i][m][k]\)</span>即为这一条木板粉刷次数为<span
class="math inline">\(k\)</span>时的最多粉刷格。</strong></p>
<p>最后，进行分类背包dp即可。</p>
<p><span class="math display">\[
dp[j] = \max(dp[j - k] + dp1[i][m][k])(k\in[0,m],i\in[1,n]) \tag{2}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 0x7ffff;</span><br><span class="line">int n, m, t;</span><br><span class="line">int a[100][100];</span><br><span class="line">int duan[N];</span><br><span class="line">int dp[1001];</span><br><span class="line">int sum[101][101][101];</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            char p;</span><br><span class="line">            cin &gt;&gt; p;</span><br><span class="line">            if (p == &#x27;1&#x27;)a[i][j] = 1 + a[i][j - 1];</span><br><span class="line">            else a[i][j] = a[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //要sum[i][m][j]</span><br><span class="line">    memset(sum, 0, sizeof(sum));</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int k = 1; k &lt;= m; k++) &#123;//涂了几次</span><br><span class="line">            for (int j = 1; j &lt;= m; j++) &#123;//这一行第几个</span><br><span class="line">                for (int q = k - 1; q &lt; j; q++) &#123;//遍历前几个少涂一次的情况</span><br><span class="line">                    sum[i][j][k] = max(sum[i][q][k - 1] + max(a[i][j] - a[i][q], j - q - (a[i][j] - a[i][q])), sum[i][j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = t; j &gt;= 1; j--) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] = max(dp[j - k] + sum[i][m][k], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="c.饥饿的奶牛">C.饥饿的奶牛</h2>
<p><strong><em>有 <span class="math inline">\(N\)</span>
个区间，每个区间 <span class="math inline">\(x,y\)</span> 表示提供的
<span class="math inline">\(x\sim y\)</span> 共 <span
class="math inline">\(y-x+1\)</span>
堆优质牧草。你可以选择任意区间但不能有重复的部分。</em></strong></p>
<p><strong><em>求出最多能吃到的牧草堆数。</em></strong></p>
<p><strong><em>数据范围：<span class="math inline">\(1 \leq n \leq 1.5
\times 10^5\)</span>，<span class="math inline">\(0 \leq x \leq y \leq 3
\times 10^6\)</span>。</em></strong></p>
<p>先对每个区间按照<span class="math inline">\(x\)</span>进行排序。</p>
<p>设<span class="math inline">\(dp[i]\)</span>为区间<span
class="math inline">\([1,i]\)</span>上能吃到的最多牧草。似乎如果用dp，时间复杂度<span
class="math inline">\(O(n^{2})\)</span>不可行，但我们可以进行双指针优化，对已经循环到的区间左端，遍历左端点相同的区间，更新每个左端点相同的区间的右端的值为选与不选改区间中的最大值，即：</p>
<p><span class="math display">\[
dp[a[p].r]=\max(dp[a[p].r],dp[a[p].l-1]+a[p].r-a[p].l+1) (p\in[1,n])
\tag{1}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
a[p].l=i \tag{2}
\]</span></p>
<p>对于<span class="math inline">\(i\)</span>而言，将其从1遍历到<span
class="math inline">\(max(a[n].r)\)</span>，由于不确定是不是某个区间的端点值，则直接与上一个值传递即可，若是端点值其转移已经在<span
class="math inline">\((1)\)</span>中体现，即：</p>
<p><span class="math display">\[
dp[i]=\max(dp[i-1],dp[i]) \tag{3}
\]</span></p>
<p>总而言之，i的遍历是为了保证动态转移的连续，而p的遍历是为了算出特别点的转移。</p>
<p>最后，在每次转移记录一次值更新答案即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N =0x7fffff;</span><br><span class="line">struct len&#123;</span><br><span class="line">    long long l = 0,r = 0;</span><br><span class="line">&#125;a[N];</span><br><span class="line">long long dp[N];</span><br><span class="line">bool cmp(len a,len b)&#123;</span><br><span class="line">    if(a.l == b.l) return a.r&lt;b.r;</span><br><span class="line">    return a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    long long maxy;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].l&gt;&gt;a[i].r;</span><br><span class="line">        maxy = max(maxy,a[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+n+1,cmp);</span><br><span class="line">    int p = 1;</span><br><span class="line">    long long ans =0;</span><br><span class="line">    for(int i=0;i&lt;=maxy;i++)&#123;</span><br><span class="line">        dp[i]=max(dp[i],dp[i-1]);</span><br><span class="line">        while(a[p].l == i &amp;&amp; p&lt;=n)&#123;//找左端点相同的</span><br><span class="line">            dp[a[p].r]=max(dp[a[p].r],dp[a[p].l-1]+a[p].r-a[p].l+1);//a[p].l-1是正好贴着a[p]的</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="记忆化搜索">2.记忆化搜索</h1>
<h2 id="a.noip2010-提高组-乌龟棋">A.[NOIP2010 提高组] 乌龟棋</h2>
<p><strong><em>乌龟棋的棋盘是一行 <span class="math inline">\(N\)</span>
个格子，每个格子上一个分数（非负整数）。棋盘第 <span
class="math inline">\(1\)</span> 格是唯一的起点，第 <span
class="math inline">\(N\)</span>
格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</em></strong></p>
<p><strong><em>乌龟棋中 <span class="math inline">\(M\)</span>
张爬行卡片，分成 <span class="math inline">\(4\)</span>
种不同的类型（<span class="math inline">\(M\)</span>
张卡片中不一定包含所有 <span class="math inline">\(4\)</span>
种类型的卡片），每种类型的卡片上分别标有 <span
class="math inline">\(1,2,3,4\)</span>
四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</em></strong></p>
<p><strong><em>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</em></strong></p>
<p><strong><em>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</em></strong></p>
<p><strong><em>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</em></strong></p>
<p><strong><em>数据范围： <span
class="math inline">\(1≤N≤350,1≤M≤120\)</span>，且 <span
class="math inline">\(4\)</span> 种爬行卡片，每种卡片的张数不会超过
<span class="math inline">\(40\)</span>；<span
class="math inline">\(0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M\)</span>。</em></strong></p>
<p>一道经典的记忆化搜索。用<span
class="math inline">\(dp[i][j][k][l]\)</span>表示用了<span
class="math inline">\(i\)</span>张一步卡，<span
class="math inline">\(j\)</span>张两步卡，<span
class="math inline">\(k\)</span>张三步卡，<span
class="math inline">\(l\)</span>张四步卡的最大分数，则有</p>
<p><span class="math display">\[
dp[c1][c2][c3][c4] =
\max(dp[c1-1][c2][c3][c4],dp[c1][c2-1][c3][c4],dp[c1][c2][c3-1][c4],dp[c1][c2][c3][c4-1])+a[c1
+ 2 * c2 + 3 * c3 + 4 * c4 + 1]
\]</span></p>
<p>其中<span
class="math inline">\(a[i]\)</span>为该位置的分数，初态为<span
class="math inline">\(dp[0][0][0][0]=a[1]\)</span>，其余赋值为<span
class="math inline">\(-1\)</span>。</p>
<p>按照上式dfs+剪枝即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n, m;</span><br><span class="line">int p[5];</span><br><span class="line">int a[400];</span><br><span class="line">int dp[40][40][40][40];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int dfs(int c1, int c2, int c3, int c4) &#123;</span><br><span class="line">    int t1 = -1, t2 = -1, t3 = -1, t4 = -1;</span><br><span class="line"></span><br><span class="line">    if (c1 != 0) &#123;</span><br><span class="line">        if (dp[c1 - 1][c2][c3][c4] != -1) t1 = dp[c1 - 1][c2][c3][c4] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t1 = dfs(c1 - 1, c2, c3, c4) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (c2 != 0) &#123;</span><br><span class="line">        if (dp[c1][c2 - 1][c3][c4] != -1) t2 = dp[c1][c2 - 1][c3][c4] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t2 = dfs(c1, c2 - 1, c3, c4) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (c3 != 0) &#123;</span><br><span class="line">        if (dp[c1][c2][c3 - 1][c4] != -1) t3 = dp[c1][c2][c3 - 1][c4] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t3 = dfs(c1, c2, c3 - 1, c4) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (c4 != 0) &#123;</span><br><span class="line">        if (dp[c1][c2][c3][c4 - 1] != -1) t4 = dp[c1][c2][c3][c4 - 1] + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">        else t4 = dfs(c1, c2, c3, c4 - 1) + a[c1 + 2 * c2 + 3 * c3 + 4 * c4 + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[c1][c2][c3][c4] = max(t1, max(t2, max(t3, t4)));</span><br><span class="line"></span><br><span class="line">    return max(t1, max(t2, max(t3, t4)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        int x; cin &gt;&gt; x;</span><br><span class="line">        p[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;= 39; i++)</span><br><span class="line">        for (int j = 0; j &lt; 40; j++)</span><br><span class="line">            for (int k = 0; k &lt; 40; k++)</span><br><span class="line">                for (int l = 0; l &lt; 40; l++)</span><br><span class="line">                    dp[i][j][k][l] = -1;</span><br><span class="line">    dp[0][0][0][0] = a[1];</span><br><span class="line">    int ans = dfs(p[1], p[2], p[3], p[4]);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="区间dp">3.区间DP</h1>
<h2 id="a.cqoi2007-涂色">A.[CQOI2007] 涂色</h2>
<p><strong><em>假设你有一条长度为 <span class="math inline">\(5\)</span>
的木板，初始时没有涂过任何颜色。你希望把它的 <span
class="math inline">\(5\)</span>
个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 <span
class="math inline">\(5\)</span> 的字符串表示这个目标：$ $
。</em></strong></p>
<p><strong><em>每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成
<span class="math inline">\(\texttt{RRRRR}\)</span> ，第二次涂成 <span
class="math inline">\(\texttt{RGGGR}\)</span> ，第三次涂成 <span
class="math inline">\(\texttt{RGBGR}\)</span>
，达到目标。</em></strong></p>
<p><strong><em>用尽量少的涂色次数达到目标。</em></strong></p>
<p><strong><em>数据范围： <span class="math inline">\(1\le n\le
50\)</span> 。</em></strong></p>
<p>裸的区间dp。方程：</p>
<p><span class="math display">\[
dp[j][i + j] = min(dp[j][i + j], dp[j][j + k] + dp[j + k + 1][j + i] -
(a[j] == a[j + i]))(i\in[2,n-1],j\in[1,n-i],k\in[0,i])
\]</span></p>
<p>其中<span class="math inline">\(a[i]\)</span> 为字符串的第<span
class="math inline">\(i\)</span> 个字符，初态为<span
class="math inline">\(dp[n][n]
=1\)</span>，同时初始化含两个字符的区间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fff;</span><br><span class="line">int a[N];</span><br><span class="line">int dp[100][100];</span><br><span class="line">char x[60];</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; x; int n = 0;</span><br><span class="line">    while (x[n] &gt;= 65) &#123;</span><br><span class="line">        a[n + 1] = x[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">            dp[i][j] = 1000;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = 1;</span><br><span class="line">        if (a[i] == a[i + 1]) dp[i][i + 1] = 1;</span><br><span class="line">        else dp[i][i + 1] = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[n][n] = 1;</span><br><span class="line">    for (int i = 2; i &lt; n; i++) &#123;//长度</span><br><span class="line">        for (int j = 1; j + i &lt;= n; j++) &#123;//起点</span><br><span class="line">            for (int k = 0; k &lt; i; k++) &#123;</span><br><span class="line">                if (a[j] == a[j + i]) dp[j][i + j] = min(dp[j][i + j], dp[j][j + k] + dp[j + k + 1][j + i] - 1);</span><br><span class="line">                else dp[j][i + j] = min(dp[j][i + j], dp[j][j + k] + dp[j + k + 1][j + i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[1][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="背包dp">4.背包DP</h1>
<h2 id="a.bjoi2019-排兵布阵">A.[BJOI2019] 排兵布阵</h2>
<p><strong><em>小 C 正在玩一款排兵布阵的游戏。在游戏中有 <span
class="math inline">\(n\)</span>
座城堡，每局对战由两名玩家来争夺这些城堡。每名玩家有 <span
class="math inline">\(m\)</span> 名士兵，可以向第 <span
class="math inline">\(i\)</span> 座城堡派遣 <span
class="math inline">\(a_i\)</span>
名士兵去争夺这个城堡，使得总士兵数不超过 <span
class="math inline">\(m\)</span>。</em></strong></p>
<p><strong><em>如果一名玩家向第 <span class="math inline">\(i\)</span>
座城堡派遣的士兵数严格大于对手派遣士兵数的两倍，那么这名玩家就占领了这座城堡，获得
<span class="math inline">\(i\)</span> 分。</em></strong></p>
<p><strong><em>现在小 C 即将和其他 <span
class="math inline">\(s\)</span> 名玩家两两对战，这 <span
class="math inline">\(s\)</span> 场对决的派遣士兵方案必须相同。小 C
通过某些途径得知了其他 <span class="math inline">\(s\)</span>
名玩家即将使用的策略，他想知道他应该使用什么策略来最大化自己的总分。</em></strong></p>
<p><strong><em>由于答案可能不唯一，你只需要输出小 C
总分的最大值。</em></strong></p>
<p><strong><em>数据范围： <span class="math inline">\(1\le s \le
100\)</span> <span class="math inline">\(1\le n \le 100\)</span> <span
class="math inline">\(1\le m \le 20000\)</span> 对于每名玩家 <span
class="math inline">\(a_i \ge 0\)</span>，<span
class="math inline">\(\sum\limits_{i=1}^n a_i \le
m\)</span></em></strong></p>
<p>分组背包裸题，方程：</p>
<p><span class="math display">\[
dp[i][j] = \max(dp[i - 1][j],dp[i - 1][j - 2 * a[i].zu[k] - 1] + i * k)
(i\in[1,n],j\in[1,m],k\in[1,s])
\]</span></p>
<p>细节：每个组要先排序，严格大于意味着花费是两倍还要再加一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n,m,s;</span><br><span class="line">struct p</span><br><span class="line">&#123;</span><br><span class="line">    int hang;</span><br><span class="line">    int zu[120];</span><br><span class="line">&#125;a[120];</span><br><span class="line"></span><br><span class="line">int b[105][105];</span><br><span class="line"></span><br><span class="line">int dp[10001][10001];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">        for(int j = 1;j &lt;= s;j++)&#123;</span><br><span class="line">            int x;cin&gt;&gt;x;</span><br><span class="line">            b[i][j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j = 1;j &lt;= s;j++)&#123;</span><br><span class="line">        for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">            a[i].zu[j] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a[j].zu + 1,a[j].zu + s + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">        for(int j = m;j &gt;= 1;j--)&#123;</span><br><span class="line">            for(int k = 1;k &lt;= s;k++)&#123;</span><br><span class="line">                if(j &gt; 2 * a[i].zu[k]) dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - 2 * a[i].zu[k] - 1] + i * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.垃圾陷阱">B.垃圾陷阱</h2>
<p><strong><em>卡门――农夫约翰极其珍视的一条 <code>Holsteins</code>
奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为
<span class="math inline">\(D\)</span>（<span class="math inline">\(2
\le D \le 100\)</span>）英尺。</em></strong></p>
<p><strong><em>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</em></strong></p>
<p><strong><em>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</em></strong></p>
<p><strong><em>假设卡门预先知道了每个垃圾扔下的时间 <span
class="math inline">\(t\)</span>（<span class="math inline">\(1 \le t
\le 1000\)</span>），以及每个垃圾堆放的高度 <span
class="math inline">\(h\)</span>（<span class="math inline">\(1 \le h
\le 25\)</span>）和吃进该垃圾能维持生命的时间 <span
class="math inline">\(f\)</span>（<span class="math inline">\(1 \le f
\le
30\)</span>），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续
<span class="math inline">\(10\)</span> 小时的能量，如果卡门 <span
class="math inline">\(10\)</span> 小时内（不含 <span
class="math inline">\(10\)</span>
小时，维持生命的时间同）没有进食，卡门就将饿死。</em></strong></p>
<p><strong><em>第一行为两个整数，<span class="math inline">\(D\)</span>
和 <span class="math inline">\(G\)</span>（<span class="math inline">\(1
\le G \le 100\)</span>），<span class="math inline">\(G\)</span>
为被投入井的垃圾的数量。</em></strong></p>
<p><strong><em>第二到第 <span class="math inline">\(G+1\)</span>
行每行包括三个整数：<span class="math inline">\(T\)</span>（<span
class="math inline">\(1 \le T \le
1000\)</span>），表示垃圾被投进井中的时间；<span
class="math inline">\(F\)</span>（<span class="math inline">\(1 \le F
\le 30\)</span>），表示该垃圾能维持卡门生命的时间；和 <span
class="math inline">\(H\)</span>（<span class="math inline">\(1 \le H
\le 25\)</span>），该垃圾能垫高的高度。</em></strong></p>
<p>将<span
class="math inline">\(D\)</span>看作背包容量，用该高度与时间的最大体力当作状态，则题目变为在限制条件求下最快填满背包的时间，吃掉用刷表法，垫起来用填表法（这是因为填表不好初始化，且不好与吃掉同步）。吃掉的方程：</p>
<p><span class="math display">\[
dp[i][j] = \max(dp[i - 1][j] + n[i].f - n[i].t + n[i-1].t) \tag{1}
\]</span></p>
<p>垫起来的方程：</p>
<p><span class="math display">\[
dp[i][j + n[i].h] = \max(dp[i][j + n[i].h],dp[i - 1][j] - n[i].t +
n[i-1].t) \tag{2}
\]</span></p>
<p>转移条件：</p>
<p><span class="math display">\[
dp[i - 1][j] \ge n[i].t - n[i-1].t \tag{3}
\]</span></p>
<p>其中<span class="math inline">\(n[i]\)</span>为对<span
class="math inline">\(t\)</span>排序后的第<span
class="math inline">\(i\)</span>物品。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int d,g;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int t,f,h;</span><br><span class="line">&#125;n[10000];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">    return a.t&lt;b.t;</span><br><span class="line">&#125;</span><br><span class="line">int dp[150][150];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;d&gt;&gt;g;</span><br><span class="line">    for(int i=1;i&lt;=g;i++)&#123;</span><br><span class="line">        cin&gt;&gt;n[i].t&gt;&gt;n[i].f&gt;&gt;n[i].h;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(n+1,n+g+1,cmp);</span><br><span class="line">    dp[0][0] = 10;</span><br><span class="line">    memset(dp,-100,sizeof(dp));</span><br><span class="line">    dp[0][0] = 10;</span><br><span class="line">    int ans = -100000;</span><br><span class="line">    for(int i = 1;i&lt;=g;i++)&#123;</span><br><span class="line">        for(int j = d; j &gt;= 0;j--)&#123;</span><br><span class="line">            if(dp[i - 1][j] &lt; n[i].t - n[i-1].t) continue;</span><br><span class="line">            if(j + n[i].h &gt;= d)&#123;</span><br><span class="line">                cout&lt;&lt;n[i].t;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = max(dp[i][j],dp[i - 1][j] + n[i].f - n[i].t + n[i-1].t);//吃掉</span><br><span class="line">            dp[i][j + n[i].h] = max(dp[i][j + n[i].h],dp[i - 1][j] - n[i].t + n[i-1].t);//垫起来</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,n[i].t + dp[i][0]);</span><br><span class="line">    &#125;//体力一定要最多</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="c.noip2014-提高组-飞扬的小鸟">C.[NOIP2014 提高组]
飞扬的小鸟</h2>
<p><strong><em>Flappy Bird
是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。</em></strong></p>
<p><strong><em>为了简化问题，我们对游戏规则进行了简化和改编:</em></strong></p>
<p><strong><em>游戏界面是一个长为 <span
class="math inline">\(n\)</span>，高为 <span
class="math inline">\(m\)</span> 的二维平面，其中有 <span
class="math inline">\(k\)</span>
个管道（忽略管道的宽度）。</em></strong></p>
<p><strong><em>小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。</em></strong></p>
<p><strong><em>小鸟每个单位时间沿横坐标方向右移的距离为 <span
class="math inline">\(1\)</span>，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度
<span
class="math inline">\(x\)</span>，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度
<span
class="math inline">\(y\)</span>。小鸟位于横坐标方向不同位置时，上升的高度
<span class="math inline">\(x\)</span> 和下降的高度 <span
class="math inline">\(y\)</span> 可能互不相同。</em></strong></p>
<p><strong><em>小鸟高度等于 <span class="math inline">\(0\)</span>
或者小鸟碰到管道时，游戏失败。小鸟高度为 <span
class="math inline">\(m\)</span> 时，无法再上升。</em></strong></p>
<p><strong><em>现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。</em></strong></p>
<p><strong><em>第 <span class="math inline">\(1\)</span> 行有 <span
class="math inline">\(3\)</span> 个整数 <span class="math inline">\(n,
m,
k\)</span>，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；</em></strong></p>
<p><strong><em>接下来的 <span class="math inline">\(n\)</span> 行，每行
<span class="math inline">\(2\)</span> 个用一个空格隔开的整数 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>，依次表示在横坐标位置 <span
class="math inline">\(0 \sim n-1\)</span>
上玩家点击屏幕后，小鸟在下一位置上升的高度 <span
class="math inline">\(x\)</span>，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度
<span class="math inline">\(y\)</span>。</em></strong></p>
<p><strong><em>接下来 <span class="math inline">\(k\)</span> 行，每行
<span class="math inline">\(3\)</span> 个整数 <span
class="math inline">\(p,l,h\)</span>，每两个整数之间用一个空格隔开。每行表示一个管道，其中
<span class="math inline">\(p\)</span> 表示管道的横坐标，<span
class="math inline">\(l\)</span> 表示此管道缝隙的下边沿高度，<span
class="math inline">\(h\)</span> 表示管道缝隙上边沿的高度（输入数据保证
<span class="math inline">\(p\)</span>
各不相同，但不保证按照大小顺序给出）。</em></strong></p>
<p><strong><em>对于 <span class="math inline">\(100\%\)</span>
的数据：<span class="math inline">\(5 \leq n \leq 10000\)</span>，<span
class="math inline">\(5 \leq m \leq 1000\)</span>，<span
class="math inline">\(0 \leq k &lt; n\)</span>，<span
class="math inline">\(0 &lt; x,y &lt; m\)</span>，<span
class="math inline">\(0 &lt; p &lt; n\)</span>，<span
class="math inline">\(0 \leq l &lt; h \leq m\)</span>， <span
class="math inline">\(l + 1 &lt; h\)</span>。</em></strong></p>
<p>建模为两个背包：上升为完全背包，下降为01背包。</p>
<p>对于下降而言没什么坑点，但对于上升而言，必须特判到最顶点的情况，以及特判在初始时刻能从原点出发。</p>
<p>最后还要注意排序也有坑点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0x7fffff;</span><br><span class="line">int n, m, k;</span><br><span class="line">struct guan</span><br><span class="line">&#123;</span><br><span class="line">    int maxh, minh, x = 0x7ff;</span><br><span class="line">&#125; n1[10500];</span><br><span class="line">struct updown</span><br><span class="line">&#123;</span><br><span class="line">    int up, down;</span><br><span class="line">&#125; move1[10500];</span><br><span class="line">int ha[10500];</span><br><span class="line">int dp[10500][1050];</span><br><span class="line">bool cmp(guan a, guan b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.x &lt; b.x ? 1 : 0;</span><br><span class="line">&#125;</span><br><span class="line">int new_h[10500][1050];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    int cnt1 = 1;</span><br><span class="line">    memset(ha, 0, sizeof(ha));</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; move1[i].up &gt;&gt; move1[i].down;</span><br><span class="line">    for (int i = 1; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ha[x]++;</span><br><span class="line">        cin &gt;&gt; n1[i].minh &gt;&gt; n1[i].maxh;</span><br><span class="line">        n1[i].x = x;</span><br><span class="line">        cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(n1 + 1, n1 + k + 1, cmp);</span><br><span class="line">    memset(dp, 0x3f, sizeof(dp));</span><br><span class="line">    int cnt2 = 1;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[0][i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        new_h[i][1] = move1[i].up;</span><br><span class="line">        int cnt = 2;</span><br><span class="line">        for (int j = 2; j * move1[i].up &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_h[i][cnt++] = j * move1[i].up;</span><br><span class="line">        &#125;</span><br><span class="line">        new_h[i][cnt] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!ha[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            for (int j = m - move1[i - 1].up; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">			    dp[i][m]=min(dp[i][m],min(dp[i][j],dp[i-1][j])+1);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][m] = min(dp[i - 1][m] + 1, dp[i][m]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ha[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j &gt;= move1[i - 1].up)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j - move1[i - 1].up] + 1);</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i][j - move1[i - 1].up] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            if (i == 1)</span><br><span class="line">                for (int j = 0; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            else</span><br><span class="line">                for (int j = 1; j &lt;= m; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (j + move1[i - 1].down &lt;= m)</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - 1][j + move1[i - 1].down]);</span><br><span class="line">                &#125;</span><br><span class="line">            for (int j = m - move1[i - 1].up; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">			    dp[i][m]=min(dp[i][m],min(dp[i][j],dp[i-1][j])+1);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][m] = min(dp[i - 1][m] + 1, dp[i][m]);</span><br><span class="line">            int res = 0x3f3f3f3f;</span><br><span class="line">            for (int j = n1[cnt2].minh + 1; j &lt;= n1[cnt2].maxh - 1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res = min(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = 1; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!(j &gt;= n1[cnt2].minh + 1 &amp;&amp; j &lt;= n1[cnt2].maxh - 1))</span><br><span class="line">                    dp[i][j] = 0x3f3f3f3f;</span><br><span class="line">            &#125;</span><br><span class="line">            if (res &gt;= 0x3f3f3f3f)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; 0 &lt;&lt; endl</span><br><span class="line">                     &lt;&lt; cnt2 - 1;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0x7ffff;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">        ans = min(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; 1 &lt;&lt; endl</span><br><span class="line">         &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr />
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>做题笔记 2023/11/8</title>
    <url>/2023/11/08/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0-2023-11-8/</url>
    <content><![CDATA[<h1 id="做题笔记-2023118">做题笔记 2023/11/8</h1>
<h3 id="a.依赖背包-noip2006-金明的预算方案">A.依赖背包 [NOIP2006
金明的预算方案]</h3>
<p><strong><em>Q:有<span class="math inline">\(n\)</span>元钱，想买<span
class="math inline">\(m\)</span>个物品，第<span
class="math inline">\(i\)</span>个物品的价格为<span
class="math inline">\(v_{i}\)</span>，重要度为<span
class="math inline">\(p_{i}\)</span>，有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主件。目标是让所有购买的物品的<span
class="math inline">\(v_{i}p_{i}\)</span>之和最大。</em></strong></p>
<p>考虑将每个物品与其子类的各种组合看成另一些物品，先不将子类存在应遍历的数据里，在
dp 到父类时遍历一遍物品的子类与其的组合。</p>
<p>例如：3 物品有两个子类 7 、8 ，先不将 7 8 放入要查的数组里，查到 3
时再查 7 8，总共有 3 、3 7 、3 8 、3 7 8
四种取法，遍历子类组合时将组合里所有的 <span
class="math inline">\(v\)</span> 和 <span
class="math inline">\(vp\)</span> 加起来看作一个新物品。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0X7FFF;</span><br><span class="line">int n,m;</span><br><span class="line">int dp[N];</span><br><span class="line">pair&lt;int,int&gt; p1[N];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; s[N]; /*（其实写之前不知道 vector 有这个用法，想用两个数组来着）*/</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int v,p,q;cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;</span><br><span class="line">        p *=v;</span><br><span class="line">        if(!q)p1[i]=&#123;v,p&#125;;</span><br><span class="line">        else s[q].push_back(&#123;v,p&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        for(int j=n;j&gt;=0;j--)&#123;</span><br><span class="line">            for(int t=0;t&lt;1&lt;&lt;s[i].size();t++)&#123;</span><br><span class="line">                int v=p1[i].first;</span><br><span class="line">                int w=p1[i].second;</span><br><span class="line">                for(int z=0;z&lt;s[i].size();z++)&#123;</span><br><span class="line">                    if(t&gt;&gt;z &amp; 1)&#123;</span><br><span class="line">                        v+=s[i][z].first;</span><br><span class="line">                        w+=s[i][z].second;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j&gt;=v) dp[j]=max(dp[j],dp[j-v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="b.分治计算几何-平面最近点对-luogu-p1429">B.分治+计算几何
[平面最近点对 Luogu P1429]</h2>
<p><strong><em>Q:给出<span
class="math inline">\(R^{2}\)</span>上的一些点，搜出这些点中最小的距离。</em></strong></p>
<p><del>爆搜即可</del> 乍一看无从下手
<del>确实无从下手</del>，但是仔细想想，有点像区间dp（能量项链）：先将这些点按横坐标排序，再将其不断二分成两个或一个点的集合：<span
class="math inline">\((x_{1},x_{2})\)</span>、<span
class="math inline">\((x_{3},x_{4})\)</span>
……如果集合只有一个点将其值设置为无穷，有两个则设置为两点距离。接着进行合并，合并时除了先求出原先两个区间的最小值中的更小值之外，只需要再考虑跨越右区间左端
<span class="math inline">\(mid\)</span>或左区间右端 <span
class="math inline">\(mid+1\)</span>
的相互“比较近”的点，与上面求出的更小值进行比较即可。（如果全部点都遍历一遍复杂度就变成<span
class="math inline">\(O(nlogn)\)</span>了，必t）</p>
<p>那么问题就落到怎么定义“比较近”了。注意到在平面中：</p>
<p><span class="math display">\[
A:(x_{A}-x_{B}&gt;m) \vee B:(y_{A}-y_{B}&gt;m) \Rightarrow d(A,B)&gt;m
\\
\]</span></p>
<p>由于是横向分割，关于 <span class="math inline">\((mid)\)</span>
不满足 <span class="math inline">\(A\)</span> 的的点互相不满足 <span
class="math inline">\(A\)</span> ，且落在一个横向距离为 <span
class="math inline">\(2m\)</span>
，纵向无线延长的条带上，而遍历条带中的点对组合时，先考察一遍 <span
class="math inline">\(B\)</span> 性质代替 <span
class="math inline">\(sqrt\)</span>()
的运算即可。（注意，遍历“近”点时，必须保证纵坐标有序）</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 0X7FFFF;</span><br><span class="line">int n;</span><br><span class="line">int flag = 0;</span><br><span class="line">struct pont&#123;</span><br><span class="line">    double first,second;</span><br><span class="line">&#125;point[N];</span><br><span class="line"></span><br><span class="line">bool cmp(pont a,pont b)&#123;</span><br><span class="line">    if(a.first==b.first) return a.second&lt;b.second;</span><br><span class="line">    else if(a.first==b.first &amp;&amp;a.second==b.second) flag=1;</span><br><span class="line">    return a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line">bool cmps(int a,int b)&#123;</span><br><span class="line">    return point[a].second&lt;point[b].second;</span><br><span class="line">&#125;</span><br><span class="line">double cal(pont a,pont b)&#123;</span><br><span class="line">    return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));</span><br><span class="line">&#125;</span><br><span class="line">int temp[N];</span><br><span class="line">double merge(int l,int r)&#123;</span><br><span class="line">    if(r-l==1)&#123;</span><br><span class="line">        return cal(point[l],point[r]);   </span><br><span class="line">    &#125;</span><br><span class="line">    else if(l==r) return N;</span><br><span class="line">    int mid = (l+r)/2;</span><br><span class="line">    double d1 = merge(l,mid);</span><br><span class="line">    double d2 = merge(mid + 1,r);</span><br><span class="line">    int k = 0;</span><br><span class="line">    double d3 = N;</span><br><span class="line">    for(int i = l; i &lt;= r;i ++)</span><br><span class="line">    if(fabs(point[mid].first-point[i].first) &lt; min(d1,d2))</span><br><span class="line">        temp[k++] = i;</span><br><span class="line">    sort(temp, temp + k, cmps);</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        for(int j=1+i;j&lt;k &amp;&amp; fabs(point[temp[j]].second-point[temp[i]].second) &lt; min(d1,d2);j++)&#123;</span><br><span class="line">            d3 = min(d3,cal(point[temp[j]],point[temp[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min(min(d1,d2),d3);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;point[i].first&gt;&gt;point[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(point+1,point+n+1,cmp);</span><br><span class="line">    printf(&quot;%.4lf&quot;,merge(1,n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="c.前缀和逆序对coci2015-20162-vudu">C.前缀和+逆序对[COCI2015-2016#2
VUDU]</h2>
<p><strong><em>Q：给定一个长度为 n 的序列以及一个数 p
，求出该序列的平均数大于 p 的连续子列的个数。</em></strong></p>
<p>看到平均数，先想到前缀和。下面对前缀和做一些数学推导。设序列为 <span
class="math inline">\(a_{n}\)</span> ，前缀和为 <span
class="math inline">\(s_{n}\)</span> ，假设某连续子列满足题意，不妨设
<span class="math inline">\(k&gt;j\)</span> ，则有</p>
<p><span class="math display">\[
{\frac{\sum_{i=j}^{k}a_{i}}{k-j}\geq p} \tag{C.1}
\]</span></p>
<p>即</p>
<p><span class="math display">\[
{\frac{s_{k}-s_{j}}{k-j}}\geq p  \Leftrightarrow s_{k}-kp\geq s_{j} -jp
\tag{C.2}\quad(j,k\in[0,n])
\]</span></p>
<p><span
class="math inline">\((2)\)</span>式右端极其对称，考虑构造新数列</p>
<p><span class="math display">\[
{b_{n}=\sum_{i=1}^{n}a_{i}-np\quad(n&gt;0)\\}\tag{C.3}
\]</span></p>
<p>特别地，令 <span class="math inline">\(b_{0}=0\)</span> ，使<span
class="math inline">\((C.2)\)</span>和 <span
class="math inline">\((C.3)\)</span> 完全等价。（这是因为 <span
class="math inline">\(j\)</span> 在 <span
class="math inline">\((C.3)\)</span> 中不能取到0，而在 <span
class="math inline">\((C.2)\)</span> 中可以取到 <span
class="math inline">\(0\)</span> ）</p>
<p>考察 <span class="math inline">\(b_{n}\)</span> 的递推式，易得</p>
<p><span class="math display">\[
{b_{n}=b_{n-1}+a_{n}-p\quad(n\geq0)\\}\tag{C.3&#39;}
\]</span></p>
<p>则题目变为求当 <span class="math inline">\(k&gt;j\)</span>时，<span
class="math inline">\(b_{j}\leq b_{k}\)</span> 的 <span
class="math inline">\((j,k)\)</span> 对数。</p>
<p>推完了，这不就求顺序对吗？两个办法：归并排序或树状数组。本人代码里用的是归并。（直接把板子弄过来的
<del>我是fw，归并改了半天不对</del>）</p>
<p>说一下树状数组的思路：简单来说就是大型哈希，先将数组初始化为0，当输入每个值时，先查询一遍前缀和加到答案上，再使树状数组的对应该值的下标的值++即可。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">const int N = 1000005;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n;</span><br><span class="line">long long a[N];</span><br><span class="line">long long s[N];</span><br><span class="line">long long s2[N];</span><br><span class="line">long long ans = 0;</span><br><span class="line">long long d[N];</span><br><span class="line">long long p;</span><br><span class="line">void msort(int L, int R)//归并求逆序对</span><br><span class="line">&#123;</span><br><span class="line">    if (L == R) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (L + R) / 2;</span><br><span class="line">    msort(L, mid); msort(mid + 1, R);</span><br><span class="line">    for (int k = L; k &lt;= R; k++)a[k] = s2[k];</span><br><span class="line">    int i = L, j = mid + 1;</span><br><span class="line">    for (int k = L; k &lt;= R; k++) &#123;</span><br><span class="line">        if ((i &lt;= mid) &amp;&amp; (a[i]&lt;a[j] || j&gt;R))s2[k] = a[i++];</span><br><span class="line">        else s2[k] = a[j++], ans += mid - i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    s2[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        s2[i] = s2[i-1] + a[i] - p;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s2 + 1, s2 + n + 1);//翻转后求逆序对</span><br><span class="line">    s2[n+1] = 0;</span><br><span class="line">    msort(1, n+1);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(比较有思维难度的题)</p>
<hr />
<h2
id="d.分类讨论实数二分icpc2020-shanghai-r-walker">D.分类讨论+实数二分[ICPC2020
Shanghai R Walker]</h2>
<p><strong><em>Q:给出一段区间[0,n],给定两个点的位置<span
class="math inline">\(\boldsymbol
{x_{A},x_{B}}\)</span>它们分别能以<span
class="math inline">\(\boldsymbol{v_{A},v_{B}}\)</span>的速率在区间内移动，速度的方向变化认为是瞬时的，A、B的移动会留下轨迹，求出这个区间被轨迹完全覆盖的最短时间。</em></strong></p>
<p>乍一看有点像物理题。这题的确有种高考板块模型的味道，即对A、B的运动状态详尽分类，搜索出每种状态的时间后取最小值。下面对状态进行分类：(不妨设
<span class="math inline">\(x_{A}&gt;x_{B}\)</span> )</p>
<p>A.二者相向而行，此时完全覆盖的时间为:</p>
<p><span class="math display">\[
min(\frac{x_{B}}{v_{B}},\frac{n-x_{A}}{v_{A}}) \tag{D.1}
\]</span></p>
<p>B.二者之一单独完全覆盖了区间，此种情况的最小时间为</p>
<p><span class="math display">\[
min(\frac{min(n-x_A,x_{A})+n}{v_{A}},\frac{min(n-x_B,x_{B})+n}{v_{B}})
\tag{D.2}
\]</span></p>
<p>C.二者各自负责自己的一边。设分界线为 <span
class="math inline">\(mid\)</span> ,则此种情况的最小值为</p>
<p><span class="math display">\[
max(\frac{min(x_{A}-mid,n-x_{A})+n-mid}{v_{A}},\frac{min(x_{B},mid-x_{B})+x_{B}}{v_{B}})
\tag{D.3}
\]</span></p>
<p>这种情况不太好直接算出来，因此对 <span
class="math inline">\((D.3)\)</span> 式的 <span
class="math inline">\(mid\)</span> 在 <span
class="math inline">\([x_{B},x_{A}]\)</span> 上进行二分搜索。</p>
<p>最后，上三式取最小值即可。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t; cin &gt;&gt; t;</span><br><span class="line">	while (t--) &#123;</span><br><span class="line">		double n, x1, v1, x2, v2; cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; v1 &gt;&gt; x2 &gt;&gt; v2;</span><br><span class="line">		if (x1 &lt; x2) &#123;</span><br><span class="line">			swap(x1, x2);</span><br><span class="line">			swap(v1, v2);</span><br><span class="line">		&#125;</span><br><span class="line">		double ans = 0;</span><br><span class="line">		ans = min(min((2 * n - x1), n + x1) / v1, min((n + x2), 2 * n - x2) / v2);</span><br><span class="line">		ans = min(ans, max(x1 / v1, (n - x2) / v2));</span><br><span class="line">		double l = x2;</span><br><span class="line">		double r = x1;</span><br><span class="line">		while (r - l &gt;= 1e-7) &#123;</span><br><span class="line">			double mid = (l + r) / 2;</span><br><span class="line">			double m = (min(n - x1, x1 - mid) + n - mid) / v1; double q = (min(mid - x2, x2) + mid) / v2;</span><br><span class="line">			ans = min(ans, max(m, q));</span><br><span class="line">			if (m &gt; q) l = mid;</span><br><span class="line">			else r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.10lf\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="e.函数stolz定理华师数分">E.函数stolz定理[华师数分]</h2>
<p><strong><em>Q：设函数<span class="math inline">\(\boldsymbol
f\)</span>定义在<span
class="math inline">\(\boldsymbol{(a,+\infty)}\)</span>上，<span
class="math inline">\(\boldsymbol f\)</span>在每一个有限区间<span
class="math inline">\(\boldsymbol
{(a,b)}\)</span>上有界，并满足</em></strong></p>
<p><span class="math display">\[
\lim_{x\rightarrow+\infty}{(f(x+1)-f(x))}=A.
\]</span></p>
<p><strong><em>证明</em></strong></p>
<p><span class="math display">\[
\lim_{x\rightarrow+\infty}\frac{f(x)}{x}=A. \tag{E}
\]</span></p>
<p>证明：由题</p>
<p><span class="math display">\[
\forall \varepsilon,\exists M&gt;0,\forall x&gt;M,\left| f(x+1)-f(x)-A
\right|&lt; \varepsilon \tag{E.1}
\]</span></p>
<p>令</p>
<p><span class="math display">\[
g(x)=\frac{f(x)}{x}
\]</span></p>
<p>设<span class="math inline">\(f(x)\)</span>的界为<span
class="math inline">\(k\)</span>，并注意到</p>
<p><span class="math display">\[
\left| \frac{f(x)}{x}-A \right|=\frac{1}{x}\left|f(x)-Ax\right|
\tag{E.2}
\]</span></p>
<p>对<span class="math inline">\((E.2)\)</span>式右端进行构造</p>
<p><span class="math display">\[
\frac{1}{x}\left|f(x)-Ax\right|=\frac{1}{x}\left|\sum_{i=x-[x-M]+1}^{x}(f(i)-f(i-1)-A)+f(x-[x-M])-A(x-[x-M])\right|
\tag{E.2&#39;}
\]</span></p>
<p>结合</p>
<p><span class="math display">\[
x-M-1&lt;[x-M]\le x-M\\ M\le x-[x-M]&lt;M+1
\]</span></p>
<p>以及<span class="math inline">\((E.2&#39;)\)</span>、<span
class="math inline">\((E.1)\)</span>和绝对值不等式易见</p>
<p><span class="math display">\[
\begin{aligned} |g(x)-A| &amp;\leq
\frac{1}{x}\{\sum_{i=x-[x-M]+1}^{x}|f(i)-f(i-1)-A|+|f(x-[x-M])|+|A(x-[x-M])|
\}\\  &amp;&lt; \frac{1}{x}([x-M]\varepsilon+|A|(M+1)+k))\\
&amp;=\frac{[x-M]\varepsilon}{x}+\frac{k+(M+1)|A|}{x}\tag{E.3}
\end{aligned}
\]</span></p>
<p>考察等式右端第二项，注意到分式上方皆为常数，即有<span
class="math inline">\(\lim_{x\rightarrow+\infty}\frac{k+(M+1)|A|}{x}=0.\)</span>从而存在正数<span
class="math inline">\(M\)</span>,当<span
class="math inline">\(x&gt;M\)</span>时，对于任给正数<span
class="math inline">\(\varepsilon\)</span> ，有 <span
class="math inline">\(\frac{k+(M+1)|A|}{x}&lt; \varepsilon\)</span>
.因此当<span class="math inline">\(x&gt;M\)</span>时，有</p>
<p><span class="math display">\[
|g(x)-A|&lt;\frac{[x-M]\varepsilon}{x}+\frac{k+(M+1)|A|}{x}&lt;2\varepsilon\tag{E.4}
\]</span></p>
<p>这就证明了<span class="math inline">\((E)\)</span>.<span
class="math inline">\(\ \ \ \square\)</span></p>
<p>评注：这题证明方法类似stolz定理的证明，即依照极限定义式进行放缩。但由于函数非离散，需要对末端进行一些处理才能达到目的。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title>洛必达</title>
    <url>/2023/11/10/page/</url>
    <content><![CDATA[<h1 id="洛必达法则练习">洛必达法则练习</h1>
<hr />
<h2
id="求lim_xrightarrow-infty-fracexx100lim_nrightarrow-infty-fracenn100">1.求<span
class="math inline">\(\lim_{x\rightarrow +\infty}
\frac{e^{x}}{x^{100}}\)</span>；<span
class="math inline">\(\lim_{n\rightarrow +\infty}
\frac{e^{n}}{n^{100}}\)</span></h2>
<p><span class="math display">\[
\lim_{x\rightarrow +\infty} \frac{e^{x}}{x^{100}}\\=\lim_{x\rightarrow
+\infty} \frac{(e^{x})^{(100)}}{100!}=+\infty.
\]</span></p>
<p>由归结原则，数列极限也为0.</p>
<hr />
<h2
id="求lim_xrightarrow-infty-fracln20xxlim_nrightarrow-infty-fracln20nn">2.求<span
class="math inline">\(\lim_{x\rightarrow +\infty}
\frac{\ln^{20}(x)}{x}\)</span>;<span
class="math inline">\(\lim_{n\rightarrow +\infty}
\frac{\ln^{20}(n)}{n}\)</span></h2>
<p><span class="math display">\[
\lim_{x\rightarrow +\infty} \frac{\ln^{20}(x)}{x}\\=\lim_{x\rightarrow
+\infty} \frac{(\ln^{20}(x))^{&#39;}}{1}=\lim_{x\rightarrow
+\infty}(20/x)\ln^{19}(x)
\]</span></p>
<p>重复求导易得极限为0.</p>
<hr />
<h2 id="求lim_xrightarrow-0-frac113xa-12xa-1xax2">3.求<span
class="math inline">\(\lim_{x\rightarrow 0}
\frac{1+(1+3x)^{a}-(1+2x)^{a}-(1+x)^{a}}{x^{2}}\)</span></h2>
<p><span class="math display">\[
\lim_{x\rightarrow 0}
\frac{1+(1+3x)^{a}-(1+2x)^{a}-(1+x)^{a}}{x^{2}}\\=\lim_{x\rightarrow 0}
\frac{3a(1+3x)^{a-1}-2a(1+2x)^{a-1}-a(1+x)^{a-1}}{2x}\\=\lim_{x\rightarrow
0}
\frac{9a(a-1)(1+3x)^{a-2}-4a(a-1)(1+2x)^{a-2}-a(a-1)(1+x)^{a-2}}{2}\\=(9a^{2}-9a-4a^{2}+4a-a^{2}+a)/2=2a^{2}-2a.
\]</span></p>
<hr />
<h2 id="若-lim_xrightarrow-0-fracln-x-lnsin-xax21求aa不为0">4.若 <span
class="math inline">\(\lim_{x\rightarrow 0^{+}} \frac{\ln x-\ln(\sin
x)}{ax^{2}}=1\)</span>，求a(a不为0)</h2>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} \frac{\ln{x}-\ln(\sin
x)}{ax^{2}}\\=\lim_{x\rightarrow 0^{+}} \frac{\ln{(x/\sin
x)}}{ax^{2}}\\=\lim_{x\rightarrow 0^{+}}\frac{(x-\sin x)/\sin x}{ax^{2}}
\tag{1}
\]</span></p>
<p>将<span class="math inline">\(\sin x\)</span>展开到第二项即得</p>
<p><span class="math display">\[
{(x\rightarrow 0^{+})} \frac{x-\sin x}{x} \sim \frac{x^{2}}{6}
\]</span></p>
<p>代入<span class="math inline">\((1)\)</span>即得</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} \frac{\ln x-\ln(\sin
x)}{ax^{2}}=\frac{1}{6a}=1 \Rightarrow a= \frac{1}{6}.
\]</span></p>
<hr />
<h2 id="证明lim_xrightarrow-0-fracxxxx1.">5.证明：<span
class="math inline">\(\lim_{x\rightarrow 0^{+}}
\frac{x^{x^{x}}}{x}=1\)</span>.</h2>
<p>设<span class="math inline">\(k\)</span>为正数，则</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} x\ln^{k}{x}=\lim_{x\rightarrow
0^{+}}\frac{\ln^{k}{x}}{1/x}=\lim_{x\rightarrow
0^{+}}\frac{k\ln^{k-1}{x}}{-1/x^{3}}
\]</span></p>
<p>连续求导得</p>
<p><span class="math display">\[
lim_{x\rightarrow 0^{+}}\frac{k\ln^{k-1}{x}}{-1/x^{3}}=lim_{x\rightarrow
0^{+}}\frac{\prod_{i=1}^{[k]}(i+k-[k])\ln^{k-[k]}{x}}{-1/x^{1+2[k]}}
\tag{1}
\]</span></p>
<p>再对<span
class="math inline">\((1)\)</span>上下求一次导即得极限为0.</p>
<p>从而</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}} \ln{x}(x^{x}-1)\\=\lim_{x\rightarrow 0^{+}}
\ln x(e^{x\ln{x}}-1)\\=\lim_{x\rightarrow 0^{+}} \ln x(x\ln x) =0.
\]</span></p>
<p>进而有</p>
<p><span class="math display">\[
\lim_{x\rightarrow 0^{+}}
\frac{x^{x^{x}}}{x}=\lim_{x\rightarrow0^{+}}e^{\ln
x(x^{x}-1)}=1.~~~\square
\]</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>分析</tag>
        <tag>极限</tag>
      </tags>
  </entry>
</search>
